## 一.String类型提供的正则相关的函数:3件事

### 1.查找敏感词

```
 用正则查找一句话中包含的敏感词,共四种情况
```

#### 1)indexOf

```
只查找一个固定的敏感词出现的位置

var i = str.indexOf("敏感词");
意为: 在str中查找第一个"敏感词"出现的下标的位置
返回值: 
	①如果找到,返回敏感词第一个字在字符串中的下标位置
	②如果未找到,则返回-1
问题: 不支持正则!只能找一种固定的敏感词
```

```html
<!--按住ctrl+滚轮，缩放字体-->
<!--输入!按回车，可生成网页基本结构-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!--第三阶段必须都用右键 live server运行！-->
  <!--网页中如果写js，都要写在script标签中-->
  <script>
    //请用户输入一条消息内容
    var msg = prompt("请输入消息内容");
    //查找消息中是否包含敏感词我草
    var i = msg.indexOf("我草");
    //如果找到敏感词，返回敏感词位置
    //如果没找到敏感词，返回-1
    //如果包含敏感词
    if(i != -1){
       //就在网页中提示红字: 包含敏感词，禁止发送
      //``和${}不会的同学去第一阶段复习模板字符串
	 //  (向) 页面(中)写  (一条HTML代码片段)
      document.write(`<h1 style="color:red">包含敏感词，禁止发送</h1>`)
    }else{//否则如果不包含敏感词
      //就在网页中提示绿字：然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说: ${msg}</h1>`)
    }
  </script>
</body>
</html>
```

#### 2)search()

```
用正则查找多种敏感词出现的位置
var i = str.search(/正则/i);
意为: 在字符串str中查找第一个符合正则要求的敏感词出现的位置
返回值: 同indexOf完全一样
	①如果找到,返回敏感词第一个字在字符串中的下标位置
	②如果未找到,返回-1
问题: 虽然在猫头鹰里有个选项可以忽略大小写,但是正则表达式天生是区分大小写的!
解决: 在第二个/后添加后缀i即可,ignore忽略大小写
问题:只能查找敏感词的位置,无法获得敏感词的内容
示例: 使用search代替indexOf查找敏感词
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //请用户输入一条消息内容
    var msg=prompt("请输入消息内容");
    //查找消息中是否包含符合正则要求的敏感词
    var i=msg.search(/([我卧]|wo)\s*([艹槽操草]|cao)/i);
    //如果找到敏感词，返回敏感词位置
    //如果没找到敏感词，返回-1
    //如果包含敏感词
    if(i!=-1){
      //就在网页中提示红字: 包含敏感词，禁止发送
      //``和${}不会的同学去第一阶段复习模板字符串
//  (向) 页面(中)写  (一条HTML代码片段)
      document.write(`<h1 style="color:red">包含敏感词，禁止发送</h1>`)
    }else{//否则如果不包含敏感词
      //就在网页中提示绿字：然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说: ${msg}</h1>`)
    }
  </script>
</body>
</html>
```

#### 3)查找敏感词的内容: 2种 match()

##### ①只查找第一个敏感词的内容和位置

```
var arr = str.match(/正则/i);
意为: 在字符串str中查找第一个符合正则要求的敏感词的内容和位置
返回值:2种:
	Ⅰ.如果找到,返回一个数组,arr:[0:"敏感词内容","index":敏感词下标位置]
	如果想获得本次找到的关键词内容:标准:arr["0"] 简写: arr[0]
	如果想获得本次找到的关键词的下标位置:标准:arr["index"] 简写arr.index
	说明: 0和index是不能改名的,因为数组是match函数返回给我们的,不是我们自己创建的
	Ⅱ.如果没找到,返回null
	问题: 如果一句话中包含多个敏感词,match默认只能找第一个敏感词,无法获得所有敏感词
```

```html
练习: 使用match查找敏感词的内容和位置

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //请用户输入一条消息内容
    var msg=prompt("请输入消息内容");
    //查找消息中第一个敏感词的内容和位置
    var arr=msg.match(/([我卧]|wo)\s*([艹槽操草]|cao)/i);
    //如果找到敏感词，返回数组
    //如果没找到敏感词，返回null
    //如果包含敏感词
    if(arr!=null){
      //就在网页中提示红字: 在位置?发现敏感词?，禁止发送
      //``和${}不会的同学去第一阶段复习模板字符串
//  (向) 页面(中)写  (一条HTML代码片段)
      document.write(`<h1 style="color:red">在位置 ${arr.index} 发现敏感词"${arr[0]}"，禁止发送</h1>`)
    }else{//否则如果不包含敏感词
      //就在网页中提示绿字：然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说: ${msg}</h1>`)
    }
  </script>
</body>
</html>
```

##### ①查找所有敏感词的内容

```
var arr = str.match(/正则/ig);  g:global,查找全部敏感词
返回值: 
	Ⅰ.如果找到敏感词,则返回一个数组,只包含所有敏感词的内容,不再包含每个敏感词的位置
	Ⅱ.如果找不到敏感词,返回null
问题: 不加g时,只能找一个,无法找所有;加g时,能找所有敏感词,但是无法获得位置
```

```html
使用match查找所有敏感词的内容:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var str="老师:请用小红 我的 朋友造句。小亮:小红是我的朋友。小然:朋友！小红是我的！";
    //希望查找出str中所有以小字开头的人名
    //因为汉字没有大小写之分，所以不用加i。
    var arr=str.match(/小[\u4e00-\u9fa5]/g);
    console.log(arr);
  </script>
</body>
</html>
```

#### 3)既查找每个关键词的内容,又查找每个关键字的位置

```
String类型没有提供这种函数
RegExp类型提供了一个reg.exec()函数
```

#### 4)总结

```
查找方法的返回值规律:
1.如果原函数返回的是下标位置,如果找不到,都返回-1
2.如果原函数返回的是一个数组或一个对象,如果找不到,都返回null
注意:如果一个函数有可能返回null!一定先判断是不是null,再使用.并且为null的情况提供备选方案.
```

### 2.替换敏感词 replace

```
将找到的敏感词替换为新内容，2种:
```

##### ①简单查询

```
①简单替换: 将所有敏感词都替换为统一的新值
a. var 变量=str.replace(/正则/ig, "新值")
		          替换
b. 意为: 替换字符串str中所有符合正则要求的敏感词为统一的新值！
c. 强调: 因为所有字符串类型都是不可变类型，所以，replace无权修改原字符串，而是返回替换后的新字符串。原字符串保持不变。所以，必须用变量接住返回值，才能获得替换后的新字符串。
数组是可变类型:数组家函数有权直接修改原数组内容的,所以大部分数组家的函数调用时,无需使用变量接住返回值,就可直接修改原数组!
```



```html
练习: 使用replace替换所有人名为**
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var str="老师:请用小红 我的 朋友造句。小亮:小红是我的朋友。小然:朋友！小红是我的！";
    // var str="you can you up!no can no bibi!";
    //先用match在替换之前找一次
    var arr=str.match(/小[\u4e00-\u9fa5]/g);
    //然后查找结果的元素个数，也就是将来要替换的个数！
    console.log(arr);//null
    //希望替换str中所有以小字开头的人名为**
    str=str.replace(/小[\u4e00-\u9fa5]/g, "**");
    console.log(str);
    //还想显示共替换了多少处！
    //基础一般: 
    //如果match找到了敏感词，才输出arr.length
    if(arr!=null){
      console.log(`共替换了${arr.length}处`);
    }else{//否则如果match没找到敏感词，就直接输出0处代替
      console.log(`共替换了0处`);
    }
    //学有余力: //复习第一阶段三目运算
    //console.log(`共替换了${arr!=null?arr.length:0}处`)
  </script>
</body>
</html>
```

#### ②高级替换

```
②高级替换: 根据每次找到的敏感词不同，动态替换成不同的新值

	a. var 变量=str.replace(/正则/ig, function(形参){
		return 根据本次"形参"获得的敏感词内容，动态生成一个新值
	  })
	  
	b. 原理: 回调函数的学习，可以靠打桩来判断执行次数，传入参数和返回值。
		1). replace会用正则表达式查找str中所有符合正则要求的敏感词
		2). 每找到一个敏感词就自动调用一次回调函数。
		3). 每次调用回调函数时，都自动将本次找到的一个敏感词内容传给形参变量。
		4). 回调函数中根据本次找到的敏感词内容，动态生成一个新值，返回出来
		5). replace函数获得回调函数返回的新值，并自动替换到字符串中本次找到的敏感词位置
```

```html
练习: 将字符串中每个单词首字母改为大写

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //鄙视题: 将字符串中每个单词首字母转为大写
    var str="you can you up";
    // 敏感词:y    c   y   u
    // 		 ↓
    str=str.replace(/\b[a-z]/ig, function(形参){
      //打桩可以让回调函数执行过程现原形！
      console.log(`调用了一次回调函数,形参=${形参},返回${形参.toUpperCase()}`);
      //形参: 4种可能: y c y u
      return 形参.toUpperCase();
      //返回: 也4种可能Y C Y U
    })
    console.log(str);//"You Can You Up";
  </script>
</body>
</html>
运行结果: 
调用了一次回调函数,形参=y,返回Y
调用了一次回调函数,形参=c,返回C
调用了一次回调函数,形参=y,返回Y
调用了一次回调函数,形参=u,返回U
You Can You Up
```

#### ③衍生操作

```
删除敏感词: 其实就是将敏感词替换为空字符串
变量=str.replace(/正则/ig, "")
```

```html
练习:(鄙视题) 定义三个函数，分别去掉字符串开头的空字符，去掉结尾的空字符，以及同时去掉字符串开头和结尾的空字符: 
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //鄙视题三个函数: 
    //修剪
    //trimLeft() 可去掉字符串开头的空字符
    //                可以改名
    // function trimLeft(字符串){
    //   var str2=字符串.replace(/^\s+/,"");
    //   return str2;
    // }
    //trimRight() 可去掉字符串结尾的空字符
    // function trimRight(字符串){
    //   var str2=字符串.replace(/\s+$/,"");
    //   return str2;
    // }
    //trim() 可去掉字符串开头和结尾的空字符
    // function trim(字符串){
    //   //因为/^\s+|\s+$/在字符串中匹配到两组敏感词，一组是开头的空字符，一组是结尾的空字符。如果想把两组空字符都替换，必须加g。
    //   return 字符串.replace(/^\s+|\s+$/g,"")
    // }
    //测试: 
    var str="   hello   world    ";
    // console.log(trimLeft(str));//"hello   world    "
    // console.log(trimRight(str));//"   hello   world"
    // console.log(trim(str));//"hello   world"
    
    //其实ES5和ES6标准中，已经新增了现成的trim系列函数，不用自己定义。
    console.log(str.trimLeft());
    console.log(str.trimRight());
    console.log(str.trim());
  </script>
</body>
</html>
运行结果： 
hello   world    
    hello   world
hello   world
```

### 3.切割字符串 split()

```
按指定的切割符,把一个完整的字符串,切割为多段子字符串
```

#### 1)简单切割:切割符是固定的

```
a. var arr=str.split("切割符")
		       切割
b. 按照字符串str中指定的切割符，将字符串切割为多段子字符串
c. 返回值: 包含切割后的多段子字符串的数组
d. 强调: 切割后的结果中，不包含切割符的！
```

#### 2)复杂切割

```
切割符不是固定的，但是却能找到规律
a. var arr=str.split(/正则/);
b. 意为: 按str中所有符合正则要求的切割符将字符串切割为多段子字符串
c. 强调: split中不用加g，也能自动找到所有符合条件的切割符！
```

```html
练习: 分别使用固定切割符和正则表达式切割字符串
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //想把电子邮件切割为用户名和域名两部分
    var email="zhangdong@tedu.cn";
    //                  |
    //      ["zhangdong","tedu.cn"]
    //            0          1
    //按@将字符串email一分为二
    var arr=email.split("@");
    console.log(arr);
    var uname=arr[0];
    var domain=arr[1];
    console.log(uname, domain);

    //想把一个英文的句子切割为单词数组
    var str="you can you up";
    //按空格切割str
    var arr=str.split(" ");
    console.log(arr);

    //如果每个单词之间的空格个数不确定有几个？
    var str="you       can you   up";
    //按一个或多个空格切割str
    var arr=str.split(/\s+/);
    console.log(arr);
  </script>
</body>
</html>
运行结果：
(2) ["zhangdong", "tedu.cn"]
zhangdong tedu.cn
(4) ["you", "can", "you", "up"]
(4) ["you", "can", "you", "up"]
```

#### 3)翻转字符串

```
a. 问题: 虽然数组和字符串都有下标，但是因为字符串和数组不是同一类型，所以字符串用不了数组家的函数！

b. 解决: 先将字符串打散为一个一个字符组成的字符数组！然后就可以调用数组家的函数。只不过，加工完成后，一定再拼接回字符串！

c. 如何将字符串打散为字符数组: 用空字符串""切割
	var arr=str.split("");
```

```html
练习:翻转字符串
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //数组家现成的reverse函数
    var arr=[1,2,3,4,5];
    arr.reverse();
        //翻转
    console.log(arr);
    
    //鄙视题: 翻转字符串： 
    var str="helloworld";
    //       0123456789.length=10
    //console.log(str[1]);//e
    //console.log(str.length);//10
    //数组家不是有reverse()函数吗?
    //错误: 
    //str.reverse();//报错：str.reverse is not a function
    //正确: 
    var arr=str.split("");//1. 打散为字符数组
    console.log(arr);
    arr.reverse();//2. 翻转字符数组的内容
    console.log(arr);
    //错误: join()什么都不写，默认用,连接每个字符
    //str=arr.join();
    //正确: 
    str=arr.join("");//3. 将翻转后的字符数组无缝拼接回字符串
    console.log(str);//"dlrowolleh"
  </script>
</body>
</html>
运行结果: 
(5) [5, 4, 3, 2, 1]
(10) ["h", "e", "l", "l", "o", "w", "o", "r", "l", "d"]
(10) ["d", "l", "r", "o", "w", "o", "l", "l", "e", "h"]
dlrowolleh
```

## 二.补充知识

```
补第一阶段: 字符串其实是一种不可变类型！
1. 不可变类型: 一旦创建值不可改变，只能整体替换！
   直接后果: 所有字符串家的函数都无权直接修改原字符串。只能创建新字符串保存加工后的结果，并返回新字符串。原字符串始终保持不变！
   强调: 所有字符串家的函数执行后的结果，必须用变量接住，才能保存下来！
2. 可变类型: 创建后，还可改变其内容。比如: 数组
   比如: 数组排序arr.sort(), 向数组中追加一个新元素arr.push(xxx), 都直接修改原数组，无需用变量=接住
```

```
补第一阶段数组本质: 
1. 索引数组: 下标都是数字的数组，比如: var arr=[1,2,3]; 
   结果: [
     0: 1,
     1: 2,
     2: 3
   ]
2. 关联数组: 下标都是自定义名称，比如: 
   var ym=[];
   ym["数学"]=89,
   ym["语文"]=61,
   ym["英语"]=91
   结果: [
     "数学": 89,
     "语文": 61,
     "英语": 91
   ]
3. 其实: js中所有数组以及对象底层都是关联数组！本质上是没有索引数组！
   (1). 数组和对象底层，其实都是名值对儿的集合
   (2). 每个数组的下标和每个对象属性的属性名，都是字符串类型
   (3). 无论访问数组的元素，还是访问对象的属性，标准写法都是["下标名称"]
   (4). 简写: 
   a. 如果下标名称不是数字，可简写为".下标名称"
   b. 如果下标是数字，只能简写为"[下标]"，不能用.
       因为".数字"和程序中的小数点冲突了！
```

## 三.RegExp对象

### 1.什么是正则表达式对象

```
正则表达式: 内存中专门保存一条正则表达式,并提供用正则表达式执行查找和验证的函数的对象.
```

### 2.为什么要有正则表达式对象

```
因为正则表达式的语法不是js语法.js不认识正则表达式,所以需要一种专门的对象让js认出正则表达式来
```

### 3.何时需要正则表达式对象

```
今后只要在js中使用正则表达式都需要先创建正则表达式对象
```

### 4.如何创建正则表达式对象: 2种

#### 1). 标准，用new创建: 

```
	a. var reg=new RegExp("正则","ig")
	b. 强调: 一定要用""，而不是//
	C.坑: ""中正则中的\x,都要变成\\x(因为正则中的\x和js字符串的转义字符冲突了),第一个\用来保护第二个\
	d.特殊:正则中和js中都有\u,且意义一样,都指unicode码,所以不用再加\保护
```

#### 2)简写，用//创建

```
a. var reg=/正则/ig
```

```
问题: 正则表达式不是固定不变的,可能需要根据其他内容动态生成
错误解决: 在//中直接写生成正则表达式的js程序语句
原因: //中是正则表达式的地盘，不认识js程序，所以写了也没用。
正确解决: 今后
	a. 如果正则表达式是固定的，首选//
	b. 如果正则表达式不是固定的，需要动态生成， 首选new RegExp(js表达式, "ig")
```

```
练习:根据服务器端返回的敏感词数组，防守敏感词
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //假设从服务器端用ajax请求过来一个敏感词数组
    //要求: 将来数组里有什么词，我们的程序就要防住什么词！
    var arr=["青天","紫烟"];
    //问题: 我们不可能提前预知从服务器返回的数组中包含哪些词！
    //解决: 将arr数组中每个关键词用|相连拼接成一个字符串
    console.log(arr.join("|"));
    //          青天|紫烟


    //我们的前端js程序
    //请用户输入一条消息内容
    var msg=prompt("请输入消息内容");
    //先定义正则表达式对象
    //问题: 自然也就不可能提前在前端程序里写死正则！
    //错误的解决: 将动态生成正则表达式的js语句，直接放入//中
    //原因: //中是正则表达式的地盘！//中不认识js语句！
    //var reg=/arr.join("|")/;
    //正确的解决: 被迫使用new RegExp("正则","ig")
    //原因: new RegExp()的参数刚好需要一个字符串！而我们有无数种方法可以拼出我们想要的任意字符串！
    var reg=new RegExp(arr.join("|"));
    //                     ||
    //      new RegExp("青天|紫烟");
    //       ||
    //var reg=/青天|紫烟/;
    console.log(reg);
    //用正则表达式对象查找消息内容中是否包含敏感词
    var i = msg.search(reg);
    //如果包含敏感词
    if(i != -1){
      //就提示红字: 包含敏感词禁止发送
      document.write(`<h1 style="color:red">包含敏感词，禁止发送</h1>`)
    }else{//否则
      //就显示: 然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说:${msg}</h1>`)
    }
  </script>
</body>
</html>
```

### 5.验证字符串格式

```
(1). var bool=reg.test(str)
(2). 意为: 用正则表达式reg，验证字符串str是否符合格式要求
(3). 返回值: 
	a. 如果字符串str符合正则表达式reg的格式要求，就返回true
	b. 如果字符串str不符合正则表达式reg的格式要求，就返回false
(4). 坑: test()，默认不要求从头到尾完全匹配。只要在字符串中可以找到部分内容与正则匹配，就返回true！
		比如: /\d{6}/.test("abc123456")   true
(5). 解决: 今后只要验证，都要在正则前加^后加$，表示从头到尾必须完整匹配
                         ^        $
                         |  \d{6}  |
		比如: /^\d{6}$/.test("abc123456")   false
```

```
练习: 验证密码格式是否符合要求
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //请用户输入一个密码，要求必须是6位数字
    var pwd=prompt("请输入密码");
    //定义正则表达式，匹配6位数字
    var reg=/^\d{6}$/;
    //用     正则 验证 密码的格式是否符合要求
    //        ↓    ↓   ↓
    var bool=reg.test(pwd);
    if(bool==true){//如果验证通过
      //就提示密码格式正确
      document.write(`<h1 style="color:green">密码格式正确</h1>`)
    }else{//否则如果验证不通过
      //就提示密码格式不正确
      document.write(`<h1 style="color:red">密码格式不正确</h1>`)
    }
  </script>
</body>
</html>
```

### 6. 查找每个敏感词的内容和位置:

```
(1). 问题: match()不加g，即可找内容，又可找位置，但是不能找所有；match()加g，虽然可以找所有，但是只能获得内容，无法获得位置——鱼和熊掌不可兼得！
(2). 解决: var arr=reg.exec(str)
	意为:查找str中第一个敏感词的内容和位置，保存在一个数组中返回
(3). 只使用一次: 和match不加g的情况是一样的！
	a. 也只找第一个敏感词
	b. 也返回一个数组: [ 0:"敏感词内容", index:敏感词位置 ]
(4). 如果希望用reg.exec()找所有敏感词的内容和位置: 
	a. 正则必须加g！
	b. 反复调用reg.exec(str)，直到reg.exec()返回null为止——用循环
	reg.exec()聪明: 自动知道要找下一个位置的敏感词！
	do{
		var arr=reg.exec(str);
		if(arr!=null){
			获得本次找到的敏感词的内容(arr[0])和位置(arr.index)
		}
	}while(arr!=null);
```

```
练习:使用reg.exec()查找一句话中每个敏感词的内容和位置
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var str="老师:请用小红 我的 朋友造句。小亮:小红是我的朋友。小然:朋友！小红是我的！";
    //只找第一个敏感词: 不要加g
    // var reg=/小[\u4e00-\u9fa5]/;
    // //先用match找: 
    // var arr=str.match(reg);
    // console.log(arr);
    // //再用reg.exec找: 
    // var arr=reg.exec(str);
    // console.log(arr);
    //想找所有: 加g
    var reg=/小[\u4e00-\u9fa5]/g;
    //先用match找: 
    var arr=str.match(reg);
    console.log(arr);
    //再reg.exec()
    //反复执行，只要本次找到了敏感词(arr!=null)，就有必要继续查找下一个
    //do while: 因为即使不确定字符串中有没有敏感词，也必须至少查找一次时，首选do while。
    do{
      var arr=reg.exec(str);//返回值=match()不加g时的返回值
      //arr:[ 0:"敏感词内容", index:敏感词位置]
      if(arr!=null){
        //console.log(arr);
        console.log(`在位置${arr.index}，发现敏感词 ${arr[0]}`)
      }
    }while(arr!=null);
  </script>
</body>
</html>
运行结果: 
(5) ["小红", "小亮", "小红", "小然", "小红"]
在位置5，发现敏感词 小红
在位置16，发现敏感词 小亮
在位置19，发现敏感词 小红
在位置27，发现敏感词 小然
在位置33，发现敏感词 小红
```

## 四.函数

### 1.函数概述

```
1.什么是函数: 程序中专门保存一段可重用的代码片段的程序结构，再起一个名字。
2. 为什么: 重用代码
3. 何时: 只要一段代码可能被反复使用，都要先将这段代码保存在函数中。然后再反复使用函数
```

### 2.创建函数

```
function 函数名(形参变量列表){
		函数体;
		return 返回值;
}
调用: var 变量 = 函数名(实参值列表)
```

### 3.形参变量

```
6. 形参变量: 
(1). 什么是: 专门接收函数执行时必需的数据的变量(虽然没有var)
(2). 为什么: 有些函数执行时，必须传入必要的数据，才能正常执行！
(3). 何时: 今后，只要一个函数执行时，必须外界传入某些数据才能正常执行时，都要定义形参变量
```

### 4.返回值

```
(1). 什么是: 一个函数的执行结果，被返回到函数外部
(2). 何时: 今后，只要函数的调用者需要获得函数的执行结果时，都要定义函数的返回值。
```

```
练习: 定义一个会做饭的函数，可以接收各种食材，做饭
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    function cook(菜,蛋,面){
      console.log(`炒${蛋}`)
      console.log(`炒${菜}`)
      console.log(`${菜}和${蛋}一起炒`)
      console.log(`煮${面}`)
      return `香喷喷的${菜}${蛋}${面}`
    }
    //周一
    var 碗=cook("西红柿","鸡蛋","面");
    console.log(碗);
    //周二: 西红柿没了，只有黄瓜；鸡蛋没了，只有辣条；面没了，只有粉丝
    var 碗=cook("黄瓜","辣条","粉丝");
    console.log(碗);
  </script>
</body>
</html>
运行结果: 
炒鸡蛋
炒西红柿
西红柿和鸡蛋一起炒
煮面
香喷喷的西红柿鸡蛋面
炒辣条
炒黄瓜
黄瓜和辣条一起炒
煮粉丝
香喷喷的黄瓜辣条粉丝
```

### 5.创建函数的三种方式

#### 1)用声明方式创建: 

```
(1). function 函数名(形参变量列表){
		函数体
		return 返回值
	 }
(2). 问题: 会被声明提前: 
	a. 什么是声明提前: 
		1). 在程序开始执行前
		2). 程序会先将var声明的变量和function声明的函数
		3). 提前到当前作用域的顶部集中创建
		4). 赋值留在原地！
	b. 缺点: 打乱程序正常的执行顺序！——JS语言广受诟病的缺陷！
```

#### 2)用赋值方式创建

```
赋值方式创建:
(1).  var 函数名变量=function(形参变量列表){ 函数体; return 返回值 }
(2). 优点: 函数不会被声明提前，保证了程序的正常执行顺序——很多大师级人物都用赋值方式创建函数。
(3). 揭示: 
	a. js中函数其实也是一个普通的对象，只不过对象中保存的是代码段不是数据而已。
	b. 函数名其实就是一个很普通的变量
	c. 函数名变量通过保存函数对象的唯一地址值，"引用"着函数对象
	d. 当调用函数时，程序先找到函数名变量->变量中的地址->保存在地址位置的函数对象->执行函数对象中保存代码段！
	c. 函数在内存中到底如何存储的
		见data中的函数.png
```

```
练习:判断声明提前后，程序的输出结果
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //鄙视题: 
    // function fun(){ console.log(1) };
    // fun(); //2
    // function fun(){ console.log(2) };
    // fun(); //2

    var fun=function(){ console.log(1) };
    fun(); //1
    var fun=function(){ console.log(2) };
    fun(); //2
  </script>
</body>
</html>
运行结果： 
1
2
```

#### 3)用new创建

```
用new 创建: 
	(1). var 函数名=new Function("形参1","形参2",...,"函数体; return 返回值")
	(2). 很少用！
	(3). 但是揭示了: function 函数名(){ ... } //被声明提前
						↓
			相当于var 函数名=function(){ ... }
						↓
			相当于var 函数名=new Function(...)
	(4). 结论: function 底层等效于 new Function()
             function的本质是创建一个函数对象
(一切函数都是一个保存代码段的对象,函数名仅仅是一个普通的)
```

### 6.函数重载overload

```
1. 问题: 一件事，根据传入实参值的不同，动态执行不同的逻辑。
2. 不好的做法: 为同一件事，每种不同的逻辑，单独定义一个函数，起一个专门的函数名
	原因: 增加了函数名和单词的数量，不好记忆，也不便于使用！
3. 好的解决方法——重载: 相同函数名，不同参数列表的多个函数，在调用时，可根据传入的实参值不同，自动选择匹配的一个函数执行！
4. 何时: 今后只要根据传入的参数值不同，自动执行不同的逻辑时，都要用重载
5. 优点: 减少了函数名和单词的个数，便于记忆和使用！
6. 如何: 
	(1). 问题: js语言不支持传统的重载方式——多个同名函数
		因为: js中多个同名函数，只有最后一个函数会覆盖之前所有同名函数而存活下来
	(2). 解决: 借助于arguments对象来变向实现重载效果
	a.  什么是arguments: 
		1). 每个函数中自带的——不用自己创建，就可直接使用
		2). 在调用函数时，能自动接收所有传入函数的实参值的——内容
		3). 类数组对象——存储结果
		i. 什么是类数组对象: 长得像数组的对象
		ii. vs 数组: 
			相同点:  1. 下标,  2. .length,  3. for循环遍历
			不同点: 类型不同！类数组对象不是数组家孩子！而是Object家的孩子。所以，类数组对象无权使用数组家的函数！——不是一家人不进一家门！
	b. 如何用arguments实现重载: 
		1). 只定义一个函数，只起一个统一的名字，不包含任何形参变量，函数内包含所有可能的逻辑
		2). 根据arguments在调用时自动接住的实参值不同，可以在函数内动态判断决定本次该执行哪种逻辑.
7. 问题: 既然js中一个函数不定义形参，照样可以传实参值，那么今后是不是都不用定义形参了？
	答: 不是!  自定义形参变量和arguments[i]
		自定义形参变量: 简单, 见名知义，可以告诉调用者如何正确使用函数正确传参
		——今后依然首选自定义形参变量
		只有参数个数不确定时，才被迫使用arguments代替！
```

```
练习:使用重载实现一个pay函数，支持三种支付方式
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //想定义一组付款函数，支持三种付款方式: 手机支付, 现金支付，刷卡支付
    //手机支付: 不需要给收款员什么东西，而是自己扫二维码
    //现金支付: 需要给收款员一笔现金
    //刷卡支付: 需要给收款员银行卡和密码两个数据
    //都是  "支付"
    function pay(                     ){
    // arguments{                     }.length=2
    //              0            1 
      //如果没有传入实参就手机支付
      if(arguments.length==0){
        console.log(`手机支付...`)
      }else if(arguments.length==1){
        //否则如果传入了1个实参就现金支付
        console.log(`现金支付...收您${arguments[0]}元`)
      }else{//否则（暂时只考虑三种情况）
        console.log(`刷卡支付...从您卡号${arguments[0]}扣款成功！`)
      }
    }
    //调用时: 
    //其它: 
    pay(); //0个实参
    pay(100); //1个实参
    pay("6553 1234","123456"); //2个实参
  </script>
</body>
</html>
运行结果: 
手机支付...
现金支付...收您100元
刷卡支付...从您卡号6553 1234扣款成功！
```

### 7.匿名函数

```
1. 什么是: 定义函数时，不指定函数名的函数
2. 为什么: 节约内存，划分临时作用域
3. 何时: 2种情况: 
	(1). 如果一个函数只使用一次时，都首选匿名函数。
	(2). 如果希望划分临时作用域，避免不同功能之间变量互相污染时
4. 如何: 2种情况: 
	(1). 绝大多数回调函数，都使用匿名函数——节约内存
	a. 因为: 匿名函数用完后，自动释放！
	b. 反例: 如果不用匿名函数，回调函数用完无法释放，浪费内存！
	(2). 匿名函数自调: 
	a. 什么是匿名函数自调: 定义一个匿名函数后，立刻调用自己！
	b. 何时: 今后几乎所有js代码都要放在匿名函数自调中！
	c. 为什么: 避免使用全局变量，造成全局污染！——今后在公司中，禁止使用全局变量！
	d. 如何: 
	(function(){
		要执行的任务
	})() //创建匿名函数后，立刻执行！
	结果: 匿名函数内用过的局部变量不会遗留在全局，而是随匿名函数一起释放了！
	强调: 匿名函数包与不包，对功能是没有影响的！但是，对内存影响很大！
```

```
练习:使用匿名函数自调禁止产生全局变量
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //不希望start变量在完事后，依然留在内存中！
    (function(){
      //获得当前系统时间
      var start=new Date(); //局部变量
      //提示: 开始加载页面内容
      alert(`开始加载页面内容, at:${start.toLocaleString()}`)
    })();
  </script>
  <script>
    //不希望end变量在使用后依然遗留在内存
    (function(){
      //获得当前系统时间
      var end=new Date(); //局部变量
      //提示:页面内容加载完成
      alert(`页面内容加载完成, at:${end.toLocaleString()}`);
    })();

    //变量start和end，在弹出提示后，就不会再使用了！
    //但是，因为start和end是全局变量，所以永久的留在window中占用内存空间，全局污染！
    console.log(window);
  </script>
</body>
</html>
运行结果: 
f12 console中，展开window，找不到start变量和end变量，说明释放了
```



