## 一.String类型提供的正则相关的函数:3件事

### 1.查找敏感词

```
 用正则查找一句话中包含的敏感词,共四种情况
```

#### 1)indexOf

```
只查找一个固定的敏感词出现的位置

var i = str.indexOf("敏感词");
意为: 在str中查找第一个"敏感词"出现的下标的位置
返回值: 
	①如果找到,返回敏感词第一个字在字符串中的下标位置
	②如果未找到,则返回-1
问题: 不支持正则!只能找一种固定的敏感词
```

```html
<!--按住ctrl+滚轮，缩放字体-->
<!--输入!按回车，可生成网页基本结构-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!--用右键 live server运行！-->
  <!--网页中如果写js，都要写在script标签中-->
  <script>
    //请用户输入一条消息内容
    var msg = prompt("请输入消息内容");
    //查找消息中是否包含敏感词我草
    var i = msg.indexOf("我草");
    //如果找到敏感词，返回敏感词位置
    //如果没找到敏感词，返回-1
    //如果包含敏感词
    if(i != -1){
       //就在网页中提示红字: 包含敏感词，禁止发送
	 //  (向) 页面(中)写  (一条HTML代码片段)
      document.write(`<h1 style="color:red">包含敏感词，禁止发送</h1>`)
    }else{//否则如果不包含敏感词
      //就在网页中提示绿字：然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说: ${msg}</h1>`)
    }
  </script>
</body>
</html>
```

#### 2)search()

```
用正则查找多种敏感词出现的位置
var i = str.search(/正则/i);
意为: 在字符串str中查找第一个符合正则要求的敏感词出现的位置
返回值: 同indexOf完全一样
	①如果找到,返回敏感词第一个字在字符串中的下标位置
	②如果未找到,返回-1
问题: 虽然在猫头鹰里有个选项可以忽略大小写,但是正则表达式天生是区分大小写的!
解决: 在第二个/后添加后缀i即可,ignore忽略大小写
问题:只能查找敏感词的位置,无法获得敏感词的内容
示例: 使用search代替indexOf查找敏感词
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //请用户输入一条消息内容
    var msg=prompt("请输入消息内容");
    //查找消息中是否包含符合正则要求的敏感词
    var i=msg.search(/([我卧]|wo)\s*([艹槽操草]|cao)/i);
    //如果找到敏感词，返回敏感词位置
    //如果没找到敏感词，返回-1
    //如果包含敏感词
    if(i!=-1){
      //就在网页中提示红字: 包含敏感词，禁止发送
	 //  (向) 页面(中)写  (一条HTML代码片段)
      document.write(`<h1 style="color:red">包含敏感词，禁止发送</h1>`)
    }else{//否则如果不包含敏感词
      //就在网页中提示绿字：然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说: ${msg}</h1>`)
    }
  </script>
</body>
</html>
```

#### 3)查找敏感词的内容: 2种 match()

##### ①只查找第一个敏感词的内容和位置

```
var arr = str.match(/正则/i);
意为: 在字符串str中查找第一个符合正则要求的敏感词的内容和位置
返回值:2种:
	Ⅰ.如果找到,返回一个数组,arr:[0:"敏感词内容","index":敏感词下标位置]
	如果想获得本次找到的关键词内容:标准:arr["0"] 简写: arr[0]
	如果想获得本次找到的关键词的下标位置:标准:arr["index"] 简写arr.index
	说明: 0和index是不能改名的,因为数组是match函数返回给我们的,不是我们自己创建的
	Ⅱ.如果没找到,返回null
	问题: 如果一句话中包含多个敏感词,match默认只能找第一个敏感词,无法获得所有敏感词
```

```html
练习: 使用match查找敏感词的内容和位置

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //请用户输入一条消息内容
    var msg=prompt("请输入消息内容");
    //查找消息中第一个敏感词的内容和位置
    var arr=msg.match(/([我卧]|wo)\s*([艹槽操草]|cao)/i);
    //如果找到敏感词，返回数组
    //如果没找到敏感词，返回null
    //如果包含敏感词
    if(arr!=null){
      //就在网页中提示红字: 在位置?发现敏感词?，禁止发送
	//  (向) 页面(中)写  (一条HTML代码片段)
      document.write(`<h1 style="color:red">在位置 ${arr.index} 发现敏感词"${arr[0]}"，禁止发送</h1>`)
    }else{//否则如果不包含敏感词
      //就在网页中提示绿字：然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说: ${msg}</h1>`)
    }
  </script>
</body>
</html>
```

##### ①查找所有敏感词的内容

```
var arr = str.match(/正则/ig);  g:global,查找全部敏感词
返回值: 
	Ⅰ.如果找到敏感词,则返回一个数组,只包含所有敏感词的内容,不再包含每个敏感词的位置
	Ⅱ.如果找不到敏感词,返回null
问题: 不加g时,只能找一个,无法找所有;加g时,能找所有敏感词,但是无法获得位置
```

```html
使用match查找所有敏感词的内容:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var str="老师:请用小红 我的 朋友造句。小亮:小红是我的朋友。小然:朋友！小红是我的！";
    //希望查找出str中所有以小字开头的人名
    //因为汉字没有大小写之分，所以不用加i。
    var arr=str.match(/小[\u4e00-\u9fa5]/g);
    console.log(arr);
  </script>
</body>
</html>
```

#### 3)既查找每个关键词的内容,又查找每个关键字的位置

```
String类型没有提供这种函数
RegExp类型提供了一个reg.exec()函数
```

#### 4)总结

```
查找方法的返回值规律:
1.如果原函数返回的是下标位置,如果找不到,都返回-1
2.如果原函数返回的是一个数组或一个对象,如果找不到,都返回null
注意:如果一个函数有可能返回null!一定先判断是不是null,再使用.并且为null的情况提供备选方案.
```

### 2.替换敏感词 replace

```
将找到的敏感词替换为新内容，2种:
```

##### ①简单查询

```
①简单替换: 将所有敏感词都替换为统一的新值
a. var 变量=str.replace(/正则/ig, "新值")
		          替换
b. 意为: 替换字符串str中所有符合正则要求的敏感词为统一的新值！
c. 强调: 因为所有字符串类型都是不可变类型，所以，replace无权修改原字符串，而是返回替换后的新字符串。原字符串保持不变。所以，必须用变量接住返回值，才能获得替换后的新字符串。
数组是可变类型:数组家函数有权直接修改原数组内容的,所以大部分数组家的函数调用时,无需使用变量接住返回值,就可直接修改原数组!
```



```html
练习: 使用replace替换所有人名为**
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var str="老师:请用小红 我的 朋友造句。小亮:小红是我的朋友。小然:朋友！小红是我的！";
    // var str="you can you up!no can no bibi!";
    //先用match在替换之前找一次
    var arr=str.match(/小[\u4e00-\u9fa5]/g);
    //然后查找结果的元素个数，也就是将来要替换的个数！
    console.log(arr);//null
    //希望替换str中所有以小字开头的人名为**
    str=str.replace(/小[\u4e00-\u9fa5]/g, "**");
    console.log(str);
    //还想显示共替换了多少处！
    //如果match找到了敏感词，才输出arr.length
    if(arr!=null){
      console.log(`共替换了${arr.length}处`);
    }else{//否则如果match没找到敏感词，就直接输出0处代替
      console.log(`共替换了0处`);
    }
    //console.log(`共替换了${arr!=null?arr.length:0}处`)
  </script>
</body>
</html>
```

#### ②高级替换

```
②高级替换: 根据每次找到的敏感词不同，动态替换成不同的新值

	a. var 变量=str.replace(/正则/ig, function(形参){
		return 根据本次"形参"获得的敏感词内容，动态生成一个新值
	  })
	  
	b. 原理: 回调函数的学习，可以靠打桩来判断执行次数，传入参数和返回值。
		1). replace会用正则表达式查找str中所有符合正则要求的敏感词
		2). 每找到一个敏感词就自动调用一次回调函数。
		3). 每次调用回调函数时，都自动将本次找到的一个敏感词内容传给形参变量。
		4). 回调函数中根据本次找到的敏感词内容，动态生成一个新值，返回出来
		5). replace函数获得回调函数返回的新值，并自动替换到字符串中本次找到的敏感词位置
```

```html
练习: 将字符串中每个单词首字母改为大写

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //鄙视题: 将字符串中每个单词首字母转为大写
    var str="you can you up";
    // 敏感词:y    c   y   u
    // 		 ↓
    str=str.replace(/\b[a-z]/ig, function(形参){
      //打桩可以让回调函数执行过程现原形！
      console.log(`调用了一次回调函数,形参=${形参},返回${形参.toUpperCase()}`);
      //形参: 4种可能: y c y u
      return 形参.toUpperCase();
      //返回: 也4种可能Y C Y U
    })
    console.log(str);//"You Can You Up";
  </script>
</body>
</html>
运行结果: 
调用了一次回调函数,形参=y,返回Y
调用了一次回调函数,形参=c,返回C
调用了一次回调函数,形参=y,返回Y
调用了一次回调函数,形参=u,返回U
You Can You Up
```

#### ③衍生操作

```
删除敏感词: 其实就是将敏感词替换为空字符串
变量=str.replace(/正则/ig, "")
```

```html
练习:(鄙视题) 定义三个函数，分别去掉字符串开头的空字符，去掉结尾的空字符，以及同时去掉字符串开头和结尾的空字符: 
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //鄙视题三个函数: 
    //修剪
    //trimLeft() 可去掉字符串开头的空字符
    //                可以改名
    // function trimLeft(字符串){
    //   var str2=字符串.replace(/^\s+/,"");
    //   return str2;
    // }
    //trimRight() 可去掉字符串结尾的空字符
    // function trimRight(字符串){
    //   var str2=字符串.replace(/\s+$/,"");
    //   return str2;
    // }
    //trim() 可去掉字符串开头和结尾的空字符
    // function trim(字符串){
    //   //因为/^\s+|\s+$/在字符串中匹配到两组敏感词，一组是开头的空字符，一组是结尾的空字符。如果想把两组空字符都替换，必须加g。
    //   return 字符串.replace(/^\s+|\s+$/g,"")
    // }
    //测试: 
    var str="   hello   world    ";
    // console.log(trimLeft(str));//"hello   world    "
    // console.log(trimRight(str));//"   hello   world"
    // console.log(trim(str));//"hello   world"
    
    //其实ES5和ES6标准中，已经新增了现成的trim系列函数，不用自己定义。
    console.log(str.trimLeft());
    console.log(str.trimRight());
    console.log(str.trim());
  </script>
</body>
</html>
运行结果： 
hello   world    
    hello   world
hello   world
```

### 3.切割字符串 split()

```
按指定的切割符,把一个完整的字符串,切割为多段子字符串
```

#### 1)简单切割:切割符是固定的

```
a. var arr=str.split("切割符")
		       切割
b. 按照字符串str中指定的切割符，将字符串切割为多段子字符串
c. 返回值: 包含切割后的多段子字符串的数组
d. 强调: 切割后的结果中，不包含切割符的！
```

#### 2)复杂切割

```
切割符不是固定的，但是却能找到规律
a. var arr=str.split(/正则/);
b. 意为: 按str中所有符合正则要求的切割符将字符串切割为多段子字符串
c. 强调: split中不用加g，也能自动找到所有符合条件的切割符！
```

```html
练习: 分别使用固定切割符和正则表达式切割字符串
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //想把电子邮件切割为用户名和域名两部分
    var email="zhangdong@tedu.cn";
    //                  |
    //      ["zhangdong","tedu.cn"]
    //            0          1
    //按@将字符串email一分为二
    var arr=email.split("@");
    console.log(arr);
    var uname=arr[0];
    var domain=arr[1];
    console.log(uname, domain);

    //想把一个英文的句子切割为单词数组
    var str="you can you up";
    //按空格切割str
    var arr=str.split(" ");
    console.log(arr);

    //如果每个单词之间的空格个数不确定有几个？
    var str="you       can you   up";
    //按一个或多个空格切割str
    var arr=str.split(/\s+/);
    console.log(arr);
  </script>
</body>
</html>
运行结果：
(2) ["zhangdong", "tedu.cn"]
zhangdong tedu.cn
(4) ["you", "can", "you", "up"]
(4) ["you", "can", "you", "up"]
```

#### 3)翻转字符串

```
a. 问题: 虽然数组和字符串都有下标，但是因为字符串和数组不是同一类型，所以字符串用不了数组家的函数！

b. 解决: 先将字符串打散为一个一个字符组成的字符数组！然后就可以调用数组家的函数。只不过，加工完成后，一定再拼接回字符串！

c. 如何将字符串打散为字符数组: 用空字符串""切割
	var arr=str.split("");
```

```html
练习:翻转字符串
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //数组家现成的reverse函数
    var arr=[1,2,3,4,5];
    arr.reverse();
        //翻转
    console.log(arr);
    
    //鄙视题: 翻转字符串： 
    var str="helloworld";
    //       0123456789.length=10
    //console.log(str[1]);//e
    //console.log(str.length);//10
    //数组家不是有reverse()函数吗?
    //错误: 
    //str.reverse();//报错：str.reverse is not a function
    //正确: 
    var arr=str.split("");//1. 打散为字符数组
    console.log(arr);
    arr.reverse();//2. 翻转字符数组的内容
    console.log(arr);
    //错误: join()什么都不写，默认用,连接每个字符
    //str=arr.join();
    //正确: 
    str=arr.join("");//3. 将翻转后的字符数组无缝拼接回字符串
    console.log(str);//"dlrowolleh"
  </script>
</body>
</html>
运行结果: 
(5) [5, 4, 3, 2, 1]
(10) ["h", "e", "l", "l", "o", "w", "o", "r", "l", "d"]
(10) ["d", "l", "r", "o", "w", "o", "l", "l", "e", "h"]
dlrowolleh
```

## 二.补充知识

```
字符串其实是一种不可变类型！
1. 不可变类型: 一旦创建值不可改变，只能整体替换！
   直接后果: 所有字符串家的函数都无权直接修改原字符串。只能创建新字符串保存加工后的结果，并返回新字符串。原字符串始终保持不变！
   强调: 所有字符串家的函数执行后的结果，必须用变量接住，才能保存下来！
2. 可变类型: 创建后，还可改变其内容。比如: 数组
   比如: 数组排序arr.sort(), 向数组中追加一个新元素arr.push(xxx), 都直接修改原数组，无需用变量=接住
```

```
数组本质: 
1. 索引数组: 下标都是数字的数组，比如: var arr=[1,2,3]; 
   结果: [
     0: 1,
     1: 2,
     2: 3
   ]
2. 关联数组: 下标都是自定义名称，比如: 
   var ym=[];
   ym["数学"]=89,
   ym["语文"]=61,
   ym["英语"]=91
   结果: [
     "数学": 89,
     "语文": 61,
     "英语": 91
   ]
3. 其实: js中所有数组以及对象底层都是关联数组！本质上是没有索引数组！
   (1). 数组和对象底层，其实都是名值对儿的集合
   (2). 每个数组的下标和每个对象属性的属性名，都是字符串类型
   (3). 无论访问数组的元素，还是访问对象的属性，标准写法都是["下标名称"]
   (4). 简写: 
   a. 如果下标名称不是数字，可简写为".下标名称"
   b. 如果下标是数字，只能简写为"[下标]"，不能用.
       因为".数字"和程序中的小数点冲突了！
```

## 三.RegExp对象

### 1.什么是正则表达式对象

```
正则表达式: 内存中专门保存一条正则表达式,并提供用正则表达式执行查找和验证的函数的对象.
```

### 2.为什么要有正则表达式对象

```
因为正则表达式的语法不是js语法.js不认识正则表达式,所以需要一种专门的对象让js认出正则表达式来
```

### 3.何时需要正则表达式对象

```
今后只要在js中使用正则表达式都需要先创建正则表达式对象
```

### 4.如何创建正则表达式对象: 2种

#### 1). 标准，用new创建: 

```
	a. var reg=new RegExp("正则","ig")
	b. 强调: 一定要用""，而不是//
	C.坑: ""中正则中的\x,都要变成\\x(因为正则中的\x和js字符串的转义字符冲突了),第一个\用来保护第二个\
	d.特殊:正则中和js中都有\u,且意义一样,都指unicode码,所以不用再加\保护
```

#### 2)简写，用//创建

```
a. var reg=/正则/ig
```

```
问题: 正则表达式不是固定不变的,可能需要根据其他内容动态生成
错误解决: 在//中直接写生成正则表达式的js程序语句
原因: //中是正则表达式的地盘，不认识js程序，所以写了也没用。
正确解决: 今后
	a. 如果正则表达式是固定的，首选//
	b. 如果正则表达式不是固定的，需要动态生成， 首选new RegExp(js表达式, "ig")
```

```
练习:根据服务器端返回的敏感词数组，防守敏感词
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //假设从服务器端用ajax请求过来一个敏感词数组
    //要求: 将来数组里有什么词，我们的程序就要防住什么词！
    var arr=["青天","紫烟"];
    //问题: 我们不可能提前预知从服务器返回的数组中包含哪些词！
    //解决: 将arr数组中每个关键词用|相连拼接成一个字符串
    console.log(arr.join("|"));
    //          青天|紫烟


    //我们的前端js程序
    //请用户输入一条消息内容
    var msg=prompt("请输入消息内容");
    //先定义正则表达式对象
    //问题: 自然也就不可能提前在前端程序里写死正则！
    //错误的解决: 将动态生成正则表达式的js语句，直接放入//中
    //原因: //中是正则表达式的地盘！//中不认识js语句！
    //var reg=/arr.join("|")/;
    //正确的解决: 被迫使用new RegExp("正则","ig")
    //原因: new RegExp()的参数刚好需要一个字符串！而我们有无数种方法可以拼出我们想要的任意字符串！
    var reg=new RegExp(arr.join("|"));
    //                     ||
    //      new RegExp("青天|紫烟");
    //       ||
    //var reg=/青天|紫烟/;
    console.log(reg);
    //用正则表达式对象查找消息内容中是否包含敏感词
    var i = msg.search(reg);
    //如果包含敏感词
    if(i != -1){
      //就提示红字: 包含敏感词禁止发送
      document.write(`<h1 style="color:red">包含敏感词，禁止发送</h1>`)
    }else{//否则
      //就显示: 然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说:${msg}</h1>`)
    }
  </script>
</body>
</html>
```

### 5.验证字符串格式

```
(1). var bool=reg.test(str)
(2). 意为: 用正则表达式reg，验证字符串str是否符合格式要求
(3). 返回值: 
	a. 如果字符串str符合正则表达式reg的格式要求，就返回true
	b. 如果字符串str不符合正则表达式reg的格式要求，就返回false
(4). 坑: test()，默认不要求从头到尾完全匹配。只要在字符串中可以找到部分内容与正则匹配，就返回true！
		比如: /\d{6}/.test("abc123456")   true
(5). 解决: 今后只要验证，都要在正则前加^后加$，表示从头到尾必须完整匹配
                         ^        $
                         |  \d{6}  |
		比如: /^\d{6}$/.test("abc123456")   false
```

```
练习: 验证密码格式是否符合要求
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //请用户输入一个密码，要求必须是6位数字
    var pwd=prompt("请输入密码");
    //定义正则表达式，匹配6位数字
    var reg=/^\d{6}$/;
    //用     正则 验证 密码的格式是否符合要求
    //        ↓    ↓   ↓
    var bool=reg.test(pwd);
    if(bool==true){//如果验证通过
      //就提示密码格式正确
      document.write(`<h1 style="color:green">密码格式正确</h1>`)
    }else{//否则如果验证不通过
      //就提示密码格式不正确
      document.write(`<h1 style="color:red">密码格式不正确</h1>`)
    }
  </script>
</body>
</html>
```

### 6. 查找每个敏感词的内容和位置:

```
(1). 问题: match()不加g，即可找内容，又可找位置，但是不能找所有；match()加g，虽然可以找所有，但是只能获得内容，无法获得位置——鱼和熊掌不可兼得！
(2). 解决: var arr=reg.exec(str)
	意为:查找str中第一个敏感词的内容和位置，保存在一个数组中返回
(3). 只使用一次: 和match不加g的情况是一样的！
	a. 也只找第一个敏感词
	b. 也返回一个数组: [ 0:"敏感词内容", index:敏感词位置 ]
(4). 如果希望用reg.exec()找所有敏感词的内容和位置: 
	a. 正则必须加g！
	b. 反复调用reg.exec(str)，直到reg.exec()返回null为止——用循环
	reg.exec()聪明: 自动知道要找下一个位置的敏感词！
	do{
		var arr=reg.exec(str);
		if(arr!=null){
			获得本次找到的敏感词的内容(arr[0])和位置(arr.index)
		}
	}while(arr!=null);
```

```
练习:使用reg.exec()查找一句话中每个敏感词的内容和位置
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var str="老师:请用小红 我的 朋友造句。小亮:小红是我的朋友。小然:朋友！小红是我的！";
    //只找第一个敏感词: 不要加g
    // var reg=/小[\u4e00-\u9fa5]/;
    // //先用match找: 
    // var arr=str.match(reg);
    // console.log(arr);
    // //再用reg.exec找: 
    // var arr=reg.exec(str);
    // console.log(arr);
    //想找所有: 加g
    var reg=/小[\u4e00-\u9fa5]/g;
    //先用match找: 
    var arr=str.match(reg);
    console.log(arr);
    //再reg.exec()
    //反复执行，只要本次找到了敏感词(arr!=null)，就有必要继续查找下一个
    //do while: 因为即使不确定字符串中有没有敏感词，也必须至少查找一次时，首选do while。
    do{
      var arr=reg.exec(str);//返回值=match()不加g时的返回值
      //arr:[ 0:"敏感词内容", index:敏感词位置]
      if(arr!=null){
        //console.log(arr);
        console.log(`在位置${arr.index}，发现敏感词 ${arr[0]}`)
      }
    }while(arr!=null);
  </script>
</body>
</html>
运行结果: 
(5) ["小红", "小亮", "小红", "小然", "小红"]
在位置5，发现敏感词 小红
在位置16，发现敏感词 小亮
在位置19，发现敏感词 小红
在位置27，发现敏感词 小然
在位置33，发现敏感词 小红
```

## 四.函数

### 1.函数概述

```
1.什么是函数: 程序中专门保存一段可重用的代码片段的程序结构，再起一个名字。
2. 为什么: 重用代码
3. 何时: 只要一段代码可能被反复使用，就要先将这段代码保存在函数中。然后再反复使用函数
```

### 2.创建函数

```
function 函数名(形参变量列表){
		函数体;
		return 返回值;
}
调用: var 变量 = 函数名(实参值列表)
```

### 3.形参变量

```
6. 形参变量: 
(1). 什么是: 专门接收函数执行时必需的数据的变量(虽然没有var)
(2). 为什么: 有些函数执行时，必须传入必要的数据，才能正常执行！
(3). 何时: 今后，只要一个函数执行时，必须外界传入某些数据才能正常执行时，都要定义形参变量
```

### 4.返回值

```
(1). 什么是: 一个函数的执行结果，被返回到函数外部
(2). 何时: 今后，只要函数的调用者需要获得函数的执行结果时，都要定义函数的返回值。
```

```
练习: 定义一个会做饭的函数，可以接收各种食材，做饭
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    function cook(菜,蛋,面){
      console.log(`炒${蛋}`)
      console.log(`炒${菜}`)
      console.log(`${菜}和${蛋}一起炒`)
      console.log(`煮${面}`)
      return `香喷喷的${菜}${蛋}${面}`
    }
    //周一
    var 碗=cook("西红柿","鸡蛋","面");
    console.log(碗);
    //周二: 西红柿没了，只有黄瓜；鸡蛋没了，只有辣条；面没了，只有粉丝
    var 碗=cook("黄瓜","辣条","粉丝");
    console.log(碗);
  </script>
</body>
</html>
运行结果: 
炒鸡蛋
炒西红柿
西红柿和鸡蛋一起炒
煮面
香喷喷的西红柿鸡蛋面
炒辣条
炒黄瓜
黄瓜和辣条一起炒
煮粉丝
香喷喷的黄瓜辣条粉丝
```

### 5.创建函数的三种方式

#### 1)用声明方式创建: 

```
(1). function 函数名(形参变量列表){
		函数体
		return 返回值
	 }
(2). 问题: 会被声明提前: 
	a. 什么是声明提前: 
		1). 在程序开始执行前
		2). 程序会先将var声明的变量和function声明的函数
		3). 提前到当前作用域的顶部集中创建
		4). 赋值留在原地！
	b. 缺点: 打乱程序正常的执行顺序！——JS语言广受诟病的缺陷！
```

#### 2)用赋值方式创建

​	  ![image](https://github.com/baozi9530/web-notes/blob/main/data/function.png)

```
赋值方式创建:
(1).  var 函数名变量=function(形参变量列表){ 函数体; return 返回值 }
(2). 优点: 函数不会被声明提前，保证了程序的正常执行顺序——很多大师级人物都用赋值方式创建函数。
(3). 揭示: 
	a. js中函数其实也是一个普通的对象，只不过对象中保存的是代码段不是数据而已。
	b. 函数名其实就是一个很普通的变量
	c. 函数名变量通过保存函数对象的唯一地址值，"引用"着函数对象
	d. 当调用函数时，程序先找到函数名变量->变量中的地址->保存在地址位置的函数对象->执行函数对象中保存的代码段！
	c. 函数在内存中到底如何存储的
```

```
练习:判断声明提前后，程序的输出结果
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //鄙视题: 
    // function fun(){ console.log(1) };
    // fun(); //2
    // function fun(){ console.log(2) };
    // fun(); //2

    var fun=function(){ console.log(1) };
    fun(); //1
    var fun=function(){ console.log(2) };
    fun(); //2
  </script>
</body>
</html>
运行结果： 
1
2
```

#### 3)用new创建

```
用new 创建: 
	(1). var 函数名=new Function("形参1","形参2",...,"函数体; return 返回值")
	(2). 很少用！
	(3). 但是揭示了: function 函数名(){ ... } //被声明提前
						↓
			相当于var 函数名=function(){ ... }
						↓
			相当于var 函数名=new Function(...)
	(4). 结论: function 底层等效于 new Function()
             function的本质是创建一个函数对象
(一切函数都是一个保存代码段的对象,函数名仅仅是一个普通的变量名称)
```

### 6.函数重载overload

```
1. 问题: 一件事，根据传入实参值的不同，动态执行不同的逻辑。
2. 不好的做法: 为同一件事，每种不同的逻辑，单独定义一个函数，起一个专门的函数名
	原因: 增加了函数名和单词的数量，不好记忆，也不便于使用！
3. 好的解决方法——重载: 相同函数名，不同参数列表的多个函数，在调用时，可根据传入的实参值不同，自动选择匹配的一个函数执行！
4. 何时: 今后只要根据传入的参数值不同，自动执行不同的逻辑时，都要用重载
5. 优点: 减少了函数名和单词的个数，便于记忆和使用！
6. 如何: 
	(1). 问题: js语言不支持传统的重载方式——多个同名函数
		因为: js中多个同名函数，最后一个函数会覆盖之前所有同名函数而存活下来
	(2). 解决: 借助于arguments对象来变向实现重载效果
	a.  什么是arguments: 
		1). 每个函数中自带的——不用自己创建，就可直接使用
		2). 在调用函数时，能自动接收所有传入函数的实参值的内容
		3). 类数组对象——存储结果
		i. 什么是类数组对象: 长得像数组的对象
		ii. vs 数组: 
			相同点:  1. 下标,  2. .length,  3. for循环遍历
			不同点: 类型不同！类数组对象不是数组家孩子！而是Object家的孩子。所以，类数组对象无权使用数组家的函数！——不是一家人不进一家门！
	b. 如何用arguments实现重载: 
		1). 只定义一个函数，只起一个统一的名字，不包含任何形参变量，函数内包含所有可能的逻辑
		2). 根据arguments在调用时自动接住的实参值不同，可以在函数内动态判断决定本次该执行哪种逻辑.
7. 问题: 既然js中一个函数不定义形参，照样可以传实参值，那么今后是不是都不用定义形参了？
	答: 不是!  自定义形参变量和arguments[i]
		自定义形参变量: 简单, 见名知义，可以告诉调用者如何正确使用函数正确传参
		——今后依然首选自定义形参变量
		只有参数个数不确定时，才被迫使用arguments代替！
```

```
练习:使用重载实现一个pay函数，支持三种支付方式
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //想定义一组付款函数，支持三种付款方式: 手机支付, 现金支付，刷卡支付
    //手机支付: 不需要给收款员什么东西，而是自己扫二维码
    //现金支付: 需要给收款员一笔现金
    //刷卡支付: 需要给收款员银行卡和密码两个数据
    //都是  "支付"
    function pay(                     ){
    // arguments{                     }.length=2
    //              0            1 
      //如果没有传入实参就手机支付
      if(arguments.length==0){
        console.log(`手机支付...`)
      }else if(arguments.length==1){
        //否则如果传入了1个实参就现金支付
        console.log(`现金支付...收您${arguments[0]}元`)
      }else{//否则（暂时只考虑三种情况）
        console.log(`刷卡支付...从您卡号${arguments[0]}扣款成功！`)
      }
    }
    //调用时: 
    //其它: 
    pay(); //0个实参
    pay(100); //1个实参
    pay("6553 1234","123456"); //2个实参
  </script>
</body>
</html>
运行结果: 
手机支付...
现金支付...收您100元
刷卡支付...从您卡号6553 1234扣款成功！
```

### 7.匿名函数

```
1. 什么是: 定义函数时，不指定函数名的函数
2. 为什么: 节约内存，划分临时作用域
3. 何时: 2种情况: 
	(1). 如果一个函数只使用一次时，都首选匿名函数。
	(2). 如果希望划分临时作用域，避免不同功能之间变量互相污染时
4. 如何: 2种情况: 
	(1). 绝大多数回调函数，都使用匿名函数——节约内存
	a. 因为: 匿名函数用完后，自动释放！
	b. 反例: 如果不用匿名函数，回调函数用完无法释放，浪费内存！
	(2). 匿名函数自调: 
	a. 什么是匿名函数自调: 定义一个匿名函数后，立刻调用自己！
	b. 何时: 今后几乎所有js代码都要放在匿名函数自调中！
	c. 为什么: 避免使用全局变量，造成全局污染！——今后在公司中，禁止使用全局变量！
	d. 如何: 
	(function(){
		要执行的任务
	})() //创建匿名函数后，立刻执行！
	结果: 匿名函数内用过的局部变量不会遗留在全局，而是随匿名函数一起释放了！
	强调: 匿名函数包与不包，对功能是没有影响的！但是，对内存影响很大！
```

```
练习:使用匿名函数自调禁止产生全局变量
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //不希望start变量在完事后，依然留在内存中！
    (function(){
      //获得当前系统时间
      var start=new Date(); //局部变量
      //提示: 开始加载页面内容
      alert(`开始加载页面内容, at:${start.toLocaleString()}`)
    })();
  </script>
  <script>
    //不希望end变量在使用后依然遗留在内存
    (function(){
      //获得当前系统时间
      var end=new Date(); //局部变量
      //提示:页面内容加载完成
      alert(`页面内容加载完成, at:${end.toLocaleString()}`);
    })();

    //变量start和end，在弹出提示后，就不会再使用了！
    //但是，因为start和end是全局变量，所以永久的留在window中占用内存空间，全局污染！匿名函数内的都是局部变量，不会产生全局变量。局部变量随匿名函数一起释放。不会污染全局。
    console.log(window);
  </script>
</body>
</html>
运行结果: 
f12 console中，展开window，找不到start变量和end变量，说明释放了
```



## 五.作用域(scope)和作用域链(scope chain)

### 1.作用域概述

```
1)什么是作用域: 一个变量的可用范围
2)本质: 作用域是内存中保存变量的对象
3)目的: 防止不同范围之间的变量相互干扰
```

### 2.作用域分类

```
在JS中共包括两级作用域:全局作用域,函数作用域
```

#### 1)全局作用域

```
全局作用域: 专门保存全局变量的区域/存储空间
		①全局变量: 在函数function之外,用var创建的变量
		②特点: 随处可用,可反复使用
	 	③全局作用域的本质: window对象
	 	④缺点: 随处可用,极易被污染
```

#### 2)函数作用域

```
 函数作用域: 专门保存仅函数内可用的局部变量的区域/存储空间
	 	①什么是局部变量: 2种
	 		Ⅰ.在函数内用var创建的变量
	 		Ⅱ.形参变量虽然没有var,但是也是局部变量
	 	②特点: 仅函数内可用,不可重用
	 	③.函数作用域的本质: 是一种专门保存局部变量的对象
```

##### 过程

###### ①第一步

```
Ⅰ.每个函数在定义时,函数对象上都包含一个"好友列表"
	 		好友列表中第一个格子暂时为空
	 		好友列表中第二个格子指向window
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/function1.png)

###### ②第二步

```
Ⅱ.当调用函数时，会临时创建本次函数调用的函数作用域对象,并将函数作用域对象的临时地址保存到函数对象的好友列表中离函数近的预留的格子里
```

###### ③第三步

```
Ⅲ.再将所有局部变量保存进临时创建的函数作用域对象中(局部变量: ①在函数内var创建的变量②形参变量)
```

###### ④第四步

```
Ⅳ.按函数对象中保存的步骤依次执行函数中的语句,操作变量
```

###### ⑤第五步

```
Ⅴ.函数执行过程中,查找变量使用时,是通过按顺序遍历好友列表中的各级作用域对象来查找变量的,函数总是优先使用好友列表中离自己近的函数作用域对象中的局部变量。除非离自己近的函数作用域对象中，没有需要的局部变量，才被迫去全局window中查找变量使用！——就近原则！
```

###### ⑥第六步

```
Ⅵ.函数调用后，自动释放好友列表中离自己近格子中的地址，等效于释放了本次函数调用所使用的函数作用域对象。等效于将本次使用的所有局部变量一起释放了！
		——所以，所有局部变量都不可重用！
		
总结: 如果函数内自己创建了所需的局部变量，则优先使用局部变量;
如果函数内自己没创建所需的局部变量，则去全局找需要的变量使用!
——先局部，后全局！
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/function2.png)

### 3.补充

```
JS中没有块/局部作用域的
1)JS中if,else,while,do while,switch case,for等{}都不是作用域
2)这些{}中的变量出了{},仍然可以使用
```

```html
// 练习: 判断以下三个程序的输出结果:
//第一段程序
<script>
    var a = 10;
    function fun() {
        var a = 100;
        a++;
        console.log(a)
    }
    fun();//101
    console.log(a);//10
</script>

//第二段程序:
<script>
    var a = 10;
    function fun() {
        a = 100;
        a++;
        console.log(a)
	}
    fun();//101
    console.log(a);//101
</script>

//第三段程序
<script>
    var a = 10;
    function fun(a) {
        a = 100;
        a++;
        console.log(a)
    }
    fun();//101
    console.log(a);//10
</script>
```

### 4.作用域链

```
1)什么是作用域链:函数对象中保存函数调用时所有可用的作用域对象的链式结构
2)其实就是上图中的"好友列表",学名就叫作用域链!
3)作用域链保存着一个函数可用的所有变量(局部变量和全局变量)
4)作用域链控制着变量的使用顺序(先局部后全局)
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/function3.png)

## 六.闭包(closure)

### 1.什么是闭包

```
1)用法: 既重用一个变量,又保护变量不被篡改的一种编程方法,无法释放,形成了闭包
2)本质: 外层函数的作用域对象被内层函数的作用域链引用着
```

### 2.为什么使用闭包

```
原因: 全局变量和局部变量都有不可兼得的优缺点
全局变量: 优点: 可重用; 缺点: 随处可用极易被污染
局部变量: 优点: 仅函数内可用,不会被污染 缺点: 不可重用
```

### 3.什么时候使用闭包

```
如果希望一个函数既可重用一个变量,又保护这个变量不会被篡改,就用闭包
```

### 4.如何使用

```
1)定义一个外层函数包裹内层函数和要保护的变量
	问题: 内层函数成了外层函数的局部变量,外部不可使用
2)外层函数将内层函数返回到外部
	说明: 内层函数不要起名,因为外部函数接住这个内层函数后,还会起新的变量名.
	问题: 函数只有调用才执行,才能获得返回结果
		 函数不调用,就不会执行,也不会获得返回结果
3)如果想使用内层函数,就必须先调用外层函数,才能获得内层函数
```

```html
//练习: 使用闭包保护钱数,并重用钱数
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //定义一个函数替小孩儿保管零花钱
    //小孩儿每花一笔钱，就从总钱数中减去花的钱，提示余额
    //问题: 比如有1000元总金额，保存在哪里？
    //要么存在全局: 虽然可以实现功能，但是极易被篡改！
    //闭包3步: 
    //1. 定义外层函数包裹要保护的变量和内层函数
    function parent(){
      //在外层函数父母内定义要保护的变量
      var total=1000;
      //2. 外层函数将内层函数返回到外部
      //生出  孩子函数
      return function(money){
        //要么存在局部: 虽然不会被篡改，但是不可重用
        total-=money;
        console.log(`花了${money}元,还剩${total}元`)
      }
    }
    //强调: 函数只有调用才执行，才能获得返回结果
    //      函数不调用，就不会执行，也不会获得返回结果！
    //3. 调用者，必须调用外层函数，才能获得函数返回的内层函数。
    var pay=parent();
    //花了100
    pay(100);//希望剩900

    //别人写的代码，可能有意或无意的篡改全局变量
    total=0;

    //又花了100
    pay(100);//希望剩800
    //又花了100
    pay(100);//希望剩700
  </script>
</body>
</html>
运行结果: 
花了100元,还剩900元
花了100元,还剩800元
花了100元,还剩700元
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/closure/closure1.png)

![image](https://github.com/baozi9530/web-notes/blob/main/data/closure/closure2.png)

![image](https://github.com/baozi9530/web-notes/blob/main/data/closure/closure3.png)

![image](https://github.com/baozi9530/web-notes/blob/main/data/closure/closure4.png)

### 5.总结

```
到底什么是闭包: 外层函数的作用域对象,因为受到内层函数的引用和保护,所以称为闭包对象

鄙视题 : 闭包形成的原因: 外层函数调用后，因为内层函数引用着外层函数的作用域对象，导致外层函数的作用域对象无法释放，形成了闭包！
闭包的缺点 : 引用闭包的内层函数,比普通的函数多占用一块内存,多占的是外层函数的作用域对象!
解决 :  如果一个闭包不再使用,应该尽快释放,保存内层函数的变量 = null;(pay = null)
```

```
问题: 多次调用外层函数妈妈，两次生出的孩子，是共用一个受保护的变量？还是各自有独立的受保护的变量？互不干扰？
答: 多次调用妈妈，生出的多个内层函数，各自有独立的闭包变量，互不影响。
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/closure/closure5.png)

```
总结: 
	(1). 妈妈一次调用生出的多个孩子，共用同一个红包
	(2). 妈妈多次调用生出的多个孩子，各自有独立的红包，互不干扰！
```

## 七.面向对象

### 1.什么是对象

```
1)狭义的解释: 程序中专门保存现实中一个具体事物的属性和功能的程序结构

2)广义的解释: js中除五种原始类型(number, string, bool, null, undefined)之外，其余无法直接保存在变量中的数据类型都称为对象。
比如: var arr=[1,2,3]; arr是数组类型的对象，简称数组
	 var now=new Date()  now是日期类型的对象，简称日期/时间对象
	 var fun=function(){ ... }  fun是函数类型的对象，简称函数
	... ...
	
在面向对象中只讨论狭义的自定义对象如何描述现实中的事物
```

### 2.什么是面向对象编程

```
程序都是先用对象结构集中存储一个事物的属性和功能，然后再按需调用对象中的属性和功能

为什么: 便于大量数据的管理和维护
```

### 3.面向对象的三大特点: 封装,继承,多态

#### 1)封装

```
什么是: 创建一个对象集中保存一个事物的属性和方法
为什么: 便于大量数据的管理和维护
何时: 今后,只要使用面向对象方式编程,都要先创建对象
```

### 4.创建对象的三种方式

#### 1)用{ }创建一个对象

```
用{}创建一个对象: {}是new Object()的简写
	  var 对象名={
		属性名 : 属性值, 
		  ... : ... ,
		方法名 : function(){
			... this.属性名 ...
		}
	  }
```

#### 2.用 new Object( )创建一个对象

```
用new Object()创建: --很少用
① 创建一个空对象: var 对象名=new Object();
② 强行向新对象中添加新属性和方法:
	对象名.属性名=属性值;
	对象名.方法名=function(){ ... }
	揭示: 对象底层其实也是关联数组
	
1). 都是名值对儿的集合

2). 都可用["属性名"]访问成员，都可简写为.属性名
	. 其实是 [""]
	强调: 如果将来属性名不是固定的，来自于其他变量，则既不能写["变量"]，又不能写.变量。只能写[变量]
	
3). 尝试获取对象或关联数组中一个不存在的属性，都不会报错！而是返回undefined
固定套路: 判断一个对象中是否包含某个属性: 强行获取，看是不是undefined
对象.属性名!==undefined   说明包含！否则，说明不包含！

4). 尝试向对象或关联数组中不存在的属性强行赋值，都不会报错！而是自动添加该属性
固定套路: 如何给一个对象添加新属性或新方法: 唯一办法: 强行赋值！
对象.新属性名=新值;
对象.新方法名=function(){ ... }

5). 都可用for in循环遍历每个属性: 
	for(var 变量 in 对象或关联数组){
		//in会依次取出对象或关联数组中每个属性名，自动保存在in前的变量中
	}
```

 #### 3.用构造函数反复创建多个相同结构的对象

```
(1). 问题: 如果需要反复创建多个相同结构的对象时，用{}代码就很冗余——重复。也不便于维护！

(2). 何时: 今后只要反复创建多个相同结构的对象时，都用构造函数来创建对象

(3)如何: 2步
	a.先用构造函数定义同一类型多个对象的相同属性结构!
		1). 什么是构造函数: 定义同一类型多个对象的相同属性结构的特殊函数
		2). function 一类对象的统一类型名(形参1, 形参2,...){
				//用this.属性名=xxx的方式，规定将来这类对象都必须有什么属性
				//问题: 属性值不能写死的，因为每个对象虽然属性结构相同，但是属性值各不相同！所以，应该用形参变量来传入具体的属性值！
				this.属性名1=形参1;
				this.属性名2=形参2;
				this.方法名=function(){ 将来构造函数中不应该包含方法定义！
					...this.属性名...
				}
			}
	b. 再用new反复调用构造函数创建多个相同结构的对象
		1). var 对象名=new 类型名(属性值1, 属性值2, ...)
		2). 鄙视: new做了几件事: 4件事
			i. 创建一个新的空对象
			ii. 自动让新子对象继承构造函数的原型对象。自动设置子对象的_ _proto_ _属性指向构造函数的原型对象。
			iii. 调用构造函数，传入属性值实参，还自动将构造函数中的this全都指向正在创建的新对象！
			结果: 构造函数中每一句话都相当于是给新对象强行赋值，自动添加该新属性。并将参数接住的属性值，保存进新对象的新属性中。
				A.每一句this.属性名=属性值,都变成了新对象.属性名=属性值
				B.因为新对象一穷二白,什么属性都没有,所以每一句”新对象.属性名=属性值”,都变成了给新对象中强行赋值!
				C.如果构造函数中包含this.方法名=function(){...},则每次调用构造函数时,都会反复创建一个新函数,给新对象使用
			iv. 返回新创建的对象地址,保存到等号左边的变量中(new有点儿return的作用)
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/new.png)

### 5.如何访问对象中的成员

```
1)访问对象中的属性: 对象.属性名
2)调用对象中的方法: 对象.方法()
```

#### 1).this

```
(1). 需求: 对象自己的方法中的内容，需要随对象自己的属性值动态变化
(2). 错误的解决: 直接在方法中写属性名
	a. 结果: 报错: 属性名 is not defined
	b. 原因: 
		1). 对象不在方法的作用域链中
		2). 方法默认只能在自己内部或全局作用域查找变量，无权擅自进入某个对象中查找属性！
		3). 对象的属性又不是全局变量
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/this1.png)

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/this2.png)

```
(3)正确的但是不好的解决: 在对象的方法中写死"对象名.属性名"
	原理: 让程序先找到指定名称的对象，.运算符可让程序进入对象中，读取对象的属性
	问题: 紧耦合，外部的对象名改变，也必须手动修改内部写死的对象名。一旦忘记修改内部的写死的对象名，程序立刻就出错！——不好！不便于维护！
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/this3.png)

```
(4)正确且好的解决方法: this
a. 什么是this: 自动获得正在调用当前函数的.前的对象 的js关键词
b. 何时: 今后只要对象的方法想使用对象自己的属性都必须加"this."
c. 强调: 今后判断this指向哪里，一定不要看它定义在哪儿！只看调用时.前是谁！
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/this4.png)

```html
练习:定义学生类型的构造函数，反复创建两个学生对象: 
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //想创建两个学生对象: lilei和hmm
    //定义所有学生类型的对象统一的属性结构: 
    //               形参变量永远可以改名，不必和属性名一致
    //               但是强烈建议形参名和属性名保持一致
    function Student(sname,sage){
      //固定所有学生都有sname和sage两个属性，都要会做自我介绍intr()
      this.sname=sname;
      this.sage=sage;
      this.intr=function(){
        console.log(`I'm ${this.sname}, I'm ${this.sage}`)
      }
    }
    //想创建lilei
    var lilei=new Student("Li Lei",11);
    console.log(lilei);
    //想创建hmm
    var hmm=new Student("Han Meimei",12);
    console.log(hmm);
  </script>
</body>
</html>
运行结果: 
Student {sname: "Li Lei", sage: 11, intr: ƒ}
Student {sname: "Han Meimei", sage: 12, intr: ƒ}
```

```
(5). 构造函数的优点是: 重用对象结构代码
(6). 问题: 如果在构造函数中包含方法定义，则每创建一个对象，都会反复创建完全相同的函数对象的副本，而不是只创建一个所有对象共用！——浪费了内存！
	但是确实所有对象都需要相同的方法！怎么办？
(7). 总结: 今后构造函数中就不应该包含方法定义
```



```
所以,在对象方法中,只要想访问对象中其他成员,都必须用this.
```

```html
// 练习:使用{}创建一个对象，并在对象方法中使用this获得对象自己的属性
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //创建一个学生对象lilei，保存李磊的: 
    //姓名: Li Lei
    //年龄: 11
    //保存李磊会做的一件事: 
    //自我介绍:
    var lilei={//不是作用域
    //js中只有两种作用域: 全局作用域，函数作用域
    //对象中的内容既不是全局，也不是函数作用域
    //对象仅仅是一种结构复杂的特殊存储结构而已！
      sname:"Li Lei",
      sage:11,
      intrSelf:function(){
        console.log(`I'm ${this.sname}, I'm ${this.sage}`)
      }//作用域链: ？个格子？
    }
    
    console.log(lilei);
    //输出李磊的年龄
    console.log(`李磊今年:${lilei.sage}`);
    //请李磊做自我介绍: 
    lilei.intrSelf();//this.sname    this.sage
    //                  ↓             ↓
    //                lilei.sname    lilei.sage
    //过了一年，李磊长了一岁
    lilei.sage++;
    //再输出李磊的年龄
    console.log(`李磊今年:${lilei.sage}`);
    //再请李磊做自我介绍: 
    lilei.intrSelf();//this.sname    this.sage
    //                  ↓             ↓
    //                lilei.sname    lilei.sage

    var intrSelf=lilei.intrSelf;
    intrSelf();// I'm undefined  I'm undefined
//其实执行的是window.intrSelf()，intrSelf()中的this指window，因为window中没有sname和sage，所以window.sname和window.sage返回undefined

  </script>
</body>
</html>
运行结果:
{sname: "Li Lei", sage: 11, intrSelf: ƒ}
李磊今年:11
I'm Li Lei, I'm 11
李磊今年:12
I'm Li Lei, I'm 12
I'm undefined, I'm undefined
```

#### 2)验证对象底层就是关联数组

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //创建lilei
    var lilei=new Object();
    console.log(lilei);//{}
    lilei.sname="Li Lei";
    lilei["sage"]=11;
    lilei.intr=function(){
      console.log(`I'm ${this.sname}, I'm ${this.sage}`)
    }
    console.log(lilei);
    lilei["intr"]();
    //尝试获取lilei的班级
    console.log(lilei["className"]);//undefined
    //尝试为李磊添加班级属性
    lilei.className="初一2班";
    console.log(lilei);

    //用关联数组
    var lilei=[];
    lilei.sname="Li Lei";
    lilei["sage"]=11;
    lilei.intr=function(){ 
      console.log(`I'm ${this.sname}, I'm ${this.sage}`)
    }
    console.log(lilei);
    lilei.intr();
    console.log(lilei.className);//undefined
    lilei["className"]="初一2班";
    console.log(lilei);
  </script>
</body>
</html>
运行结果: 
{}
{sname: "Li Lei", sage: 11, intr: ƒ}
I'm Li Lei, I'm 11
undefined
{sname: "Li Lei", sage: 11, className: "初一2班", intr: ƒ}
 [sname: "Li Lei", sage: 11, intr: ƒ]
I'm Li Lei, I'm 11
undefined
[sname: "Li Lei", sage: 11, className: "初一2班", intr: ƒ]
```

#### 3)总结

```
总结:
Ⅰ.如果访问成员时,已知成员的属性名,那么”.属性名”和[“属性名”]都行
Ⅱ.万一属性名中包含-,比如”font-size”,就必须用[“font-size”],不能用.font-size
Ⅲ.如果访问成员时,成员的属性名不确定,来自于一个变量或者需要动态拼接生成,就只能用[变量名或js表达式],一定不要加""
```

### 6.克隆一个对象

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/clone.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //定义函数，可以克隆一个对象
    function 克隆(旧对象){
      //1. 先创建一个新的空对象
      var 新对象={};
      //2. 遍历旧对象中每个属性
      for(var 旧属性名 in 旧对象){
        //3. 每遍历一个属性，就为新对象添加同名的属性，值为旧对象中同名属性值
        //取出旧对象中旧属性值
        //放入
        //新对象中强行添加的同名属性中
        新对象[旧属性名]=旧对象[旧属性名]
        //           ←搬家←
        //千万不能加""，因为 旧属性名 是in前的一个变量，变量值每遍历到一个新属性时，获得的属性名都不一样！是变化的！所以不能加""
        //也不能用.旧属性名。因为.等效于[""]
      }
      //返回创建好的新对象
      return 新对象;
    }
    //测试: 
    var lilei={
      sname:"Li Lei",
      sage:11
    }
    //错误: 
    //var lilei2=lilei;//将lilei变量中保存的旧对象地址复制一份给lilei2变量。结果: lilei2和lilei使用相同的对象地址，引用同一个对象！——不叫克隆！
    //正确: 
    var lilei2=克隆(lilei);
    console.log(lilei);
    console.log(lilei2);
    console.log(lilei==lilei2);//false
    //如果==左右都是对象，则==不再比较对象内容，而是比较两个对象的地址是否相同！
    //如果返回true，说明克隆失败！因为地址是同一个对象，说明没有多出一个对象
    //如果返回false，说明克隆成功！因为地址不同！说明是先后创建的两个对象！
  </script>
</body>
</html>
运行结果: 
{sname: "Li Lei", sage: 11}
{sname: "Li Lei", sage: 11}
false
```

### 7.面向对象的三大特点之继承

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/inherit.png)

```
1)js中的继承都是通过继承原型对象来实现的
2)什么是原型对象:专门保存一个类型的所有子对象共有的成员的父对象
3)何时: 今后在js中,只要为一个类型下的所有子对象定义共有的成员,都要放在父对象/原型对象中
	1. 什么是继承: 父对象中的成员，子对象无需重复创建，就可直接使用！
	2. 何时: 同一类型的所有子对象，都需要相同的方法或属性值时，都会用继承的方式来实现。
	3. 如何: 
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/inherit2.png)

```
(1). (自动，不需要你手写！) 其实当我们定义一个构造函数时，js程序都会自动赠送我们一个原型对象(prototype)，也称为该类型下所有孩子的父对象。
(2). 什么是原型对象(prototype)：替所有子对象保存共有方法和属性值的父对象
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/inherit3.png)

```
(3). (自动，不需要你手写！) 当new一个新对象时，new的第二步是自动让新子对象继承构造函数的原型对象。自动设置子对象的_ _proto_ _属性指向构造函数的原型对象。
(4). 结果，将来用子对象试图访问一个子对象没有的共有方法或属性时，js程序先在子对象自身内部查找。如果子对象内部没有，js程序会自动沿_ _proto_ _向父对象(原型对象)中查找是否包含要用的方法或属性。只要在父对象（原型对象）中找到想要的方法，依然可以用"子对象.共有方法名()"调用。看起来就像子对象在用自己的方法一样！
(5). 问题: 构造函数的原型对象开始时是空的！如何向原型对象中添加共有属性和方法？——唯一的办法只有“强行赋值”！
		构造函数.prototype.共有方法名=function(){ ... }
4. 总结: 今后，只要所有子对象都要共有的方法或属性值，都要集中保存在构造函数的原型对象中！
5. 问题: 为什么指同一个原型对象，从构造函数访问时，要用prototype属性，而从子对象访问时却要用_ _proto_ _。构造函数的prototype属性和子对象的_ _proto_ _指的到底是不是同一个对象呢？
	答: prototype和_ _proto_ _，指的是同一个对象。只不过，通过不同辈分的其它对象访问同一个原型对象时，称呼不同！
6. 问题: 原型对象中的this指谁？
	(1). 错误: 因为构造函数.prototype.共有方法=function(){ ... }
			所以共有方法中的this指.前的原型对象！
	  因为: 这句话只是向原型对象中添加函数，并不是调用共有方法。
	(2). 正确: 判断this不要看定义在哪儿，应该看何时被谁调用！
	  因为共有方法迟早会被"子对象.共有方法()"调用。所以，共有方法中的this不确定。但是肯定指将来正在调用这个共有方法的.前的某个子对象。
```

```html
//练习: 为所有学生的原型对象中添加共用的自我介绍方法
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //构造函数
    function Student(sname,sage){
      this.sname=sname;
      this.sage=sage;
    }
    //因为今后所有学生对象都要能自我介绍，所以，应该在学生类型的构造函数的原型对象中强行添加一个intr()方法。供将来所有学生共用！
    Student.prototype.intr=function(){
      console.log(`I'm ${this.sname}, I'm ${this.sage}`)
    }
    console.dir(Student);

    //想创建lilei
    var lilei=new Student("Li Lei",11);
    //想创建hmm
    var hmm=new Student("Han Meimei",12);
    
    console.log(lilei);
    console.log(hmm);
    lilei.intr();
    hmm.intr();
    //亲自鉴定: 
    //判断李磊的爹是不是构造函数妈妈的原型对象
    console.log(lilei.__proto__==Student.prototype);//true
    //判断hmm的爹是不是构造函数妈妈的原型对象
    console.log(hmm.__proto__==Student.prototype);//true
    //判断lilei的爹和hmm的爹是不是同一个人
    console.log(lilei.__proto__==hmm.__proto__);//true
  </script>
</body>
</html>
```

### 8.自有属性和共有属性

```
自有属性和共有属性: 
	(1). 什么是: 
		a. 自有属性: 保存在当前对象内部，仅归当前对象自己所有的属性
		b. 共有属性: 保存在原型对象(父对象)中，归多个子对象共有的属性
		
	(2). 获取属性值: 无论自有属性，还是共有属性，都可用"子对象.属性名"，用法是相同的！
	
	(3). 修改属性值: 
	a. 自有属性: 应该用子对象直接修改。子对象.自有属性名=属性值
	b. 共有属性: 
		1). 错误: 用子对象.共有属性方式=新值
			因为: 共有属性归所有子对象共用，如果允许某一个子对象擅自篡改，则牵一发而动全身！——危险！
			所以: js禁止子对象修改原型对象中的共有属性
			但是: 如果强行用子对象.共有属性=新值，js程序会自动给这个子对象添加一个自有的同名属性保存新属性值。而不会影响原型对象中的共有属性
			结果: 从此，这个子对象，在这个共有属性的使用上，与其他子对象，分道扬镳！
		2). 正确: 共有属性，只能用原型对象修改: 构造函数.prototype.共有属性=新值
		
	(4). 示例: 为李磊和hmm添加共有属性className，存储二人共同的班级名，并用正确和错误的方式分别修改共有属性className，查看结果: 
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/prototype.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //构造函数
    function Student(sname,sage){
      this.sname=sname;
      this.sage=sage;
    }
    //所有学生都来自初一2班，所以应该在原型对象中添加一个className属性保存所有学生统一的班级
    Student.prototype.className="初一2班";

    //创建lilei
    var lilei = new Student("Li Lei",11);
    //创建hmm
    var hmm = new Student("Han Meimei",12);
    console.log(lilei);
    console.log(hmm);
    //读取李磊的姓名和班级
    console.log(lilei.sname, lilei.className);
    //读取hmm的姓名和班级
    console.log(hmm.sname, hmm.className);
    //李磊想改名叫李晓磊
    lilei.sname="Li Xiaolei";
    console.log(lilei);
    //第一年，输出两个人的班级
    console.log(lilei.className, hmm.className);
    //过了一年，两个人同时升级到初二2班
    //错误: 用某个一个子对象，试图修改原型对象中的共有属性值
    lilei.className="6年级2班";
    //正确: 
    //Student.prototype.className="初二2班";
    //再输出两个人的班级，希望两人都是初二2班
    console.log(lilei.className, hmm.className);
    //又过了一年，大家一起升初三2班
    Student.prototype.className="初三2班";
    console.log(lilei.className, hmm.className);
  </script>
</body>
</html>
运行结果：
Student {sname: "Li Lei", sage: 11}
Student {sname: "Han Meimei", sage: 12}
Li Lei 初一2班
Han Meimei 初一2班
Student {sname: "Li Xiaolei", sage: 11}
初一2班 初一2班
6年级2班 初一2班
6年级2班 初三2班
```

### 9.内置对象的原型对象

```
(1). 什么是内置类型/内置对象: ECMAScript标准中规定的，浏览器已经实现的对象或类型。
(2). 11种: 
	String  Number  Boolean
	Array  Date   RegExp   Math(不是类型，已经是一个对象了)
	Error
	Function  Object
	global(在浏览器中被window代替)
(3). 什么是类型: 构造函数+原型对象形成的整体
	a. 构造函数负责: 创建该类型的子对象。构造函数中的所有属性会成为将来子对象内的自有属性
	b. 原型对象负责: 集中保存该类型所有子对象公共的成员（属性值和方法）。原型对象中的方法和属性值都会成为将来所有子对象的共有成员。
(4). 问题: 我怎么知道数组家共有哪些函数？
		只要看类型.prototype中有哪些函数即可！
(5). 问题: 如果经常对数组执行一种操作，但是原型对象中没有提供现成的函数可用，怎么办？——只要自定义一个函数，强行添加到数组的原型对象中即可!
		Array.prototype.新函数名=function(){
			//this->今后调用这个函数的.前的某个子对象
		}
	结果: 将来任何一个数组都可以.新函数名()
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/prototype2.png)

```html
//练习: 为数组类型添加一个对所有元素求和的共有函数
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //项目中，经常需要对各种数组内容求和
    //应该自定义一个sum函数，强行添加到数组类型的原型对象中
    Array.prototype.sum=function(){
      console.log(`调用我自己定义的sum()函数！`);
      //this->将来调用这个sum()函数的.前的某个数组
      //比如，将来arr1.sum()，this->arr1
      //     将来arr2.sum(), this->arr2
      //对当前正在调用sum()的某个数组中所有元素求和
      var result=0;
      //遍历数组中每个元素
      for(var i=0;i<this.length;i++){
        result+=this[i]
      }
       //错误: in会把sum()函数本身的定义也遍历进来
      // for(var key in this){
      //   result+=this[key]
      // }
      return result;
    }
    console.log(Array.prototype);
    
    //希望: 
    var arr1=[1,2,3];
    var arr2=[1,2,3,4,5];
    console.log(arr1.sum())//6; //报错: sum不是一个函数
    console.log(arr2.sum())//15
  </script>
</body>
</html>
运行结果: 
[sum: ƒ, constructor: ƒ, concat: ƒ, ...]
调用我自己定义的sum()函数！
6
调用我自己定义的sum()函数！
15
```

### 10.原型链: 

```
A.其实每个原型对象也有__proto__指向自己的父级对象
B.因为原型对象是自动创建的,所以原型对象的__proto__都统一指向顶级父类型--Object类型
C.Object的原型对象=null,所以Object类型是顶级父类型
	(1). 什么是原型链: 由多级父对象，逐级继承，形成的链式结果
	(2). 原型链保存着一个对象可用的所有属性和方法
	(3). 原型链控制着属性和方法的使用顺序：先自有，再共有——就近原则
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/prototype3.png)

```
	(4). 问题: 不同类型的子对象，调用toString()，输出的结果格式千差万别！
```

### 11.面向对象的三大特点之多态

```
1. 什么是多态: 一个函数，不同情况下，表现出不同的状态！
2. 其实多态分两种情况:  
	(1). 重载(overload): 一个函数，根据传入的实参值不同，执行不同的逻辑！(已学过)
	(2). 重写(override): 
			 推翻
3. 什么是重写: 在子对象中定义一个和父对象中成员同名的成员！
4. 为什么: 因为从爹继承来的东西，不总是好用的！
5. 何时重写: 今后，只要从爹继承来的东西不好用！就用重写自己的！
6. 如何: 只要在当前子对象中定义一个和父对象中不好用的成员同名的新成员即可。
7. 结果: 根据就近原则，优先使用子对象自己定义的。不再使用父对象中不好用——推翻
8. 问题: 不同类型的子对象，调用toString()，输出的结果格式千差万别？
	答: 所有内置类型的原型对象中，为了自己家孩子着想，已经重写了适合自己家孩子的toString()
9. 问题: 但是，咱们自己定义的类型中还没有重写toString()方法，所以非常不便于调试对象的内容！
	解决: 强烈建议所有自定义类型和自定义对象，都要重写自定义的toString()方法，便于调试！
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/prototype4.png)

```html
//练习: 为自定义类型重写toString()方法
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    function Student(sname,sage){
      this.sname=sname;
      this.sage=sage;
    }
    //为了让Student家的孩子们，也有好用的toString()，需要在Student的原型对象中，添加一个自定义的好用的toString()
    Student.prototype.toString=function(){
      //字符串格式和内容可以自定义
      return `{
        学生姓名: ${this.sname},
        学生年龄: ${this.sage}
      }`
    }

    var lilei=new Student("Li Lei",11);
    var arr1=new Array(1,2,3);
    var now=new Date();
    //分别输出函数，lilei，arr1和now的toString()
    console.log(Student.toString());
    console.log(lilei.toString());
    console.log(arr1.toString());
    console.log(now.toString());
  </script>
</body>
</html>
运行结果: 
function Student(sname,sage){
      this.sname=sname;
      this.sage=sage;
    }
{
        学生姓名: Li Lei,
        学生年龄: 11
      }
1,2,3
Fri Jul 03 2020 18:11:06 GMT+0800 (中国标准时间)
```

### 12.面向对象总结

```
1. 封装: 先创建对象: 2种: 
   (1). 如果只创建一个对象: {}
   (2). 如果反复创建多个相同结构的对象: 构造函数
2. 继承: 所有子对象共用的方法和属性值，必须集中定义在原型对象中
3. 多态: 如果父对象继承来的成员不好用！可以重写自己的！
```

### 13.for in 循环

```
补: for in 循环，禁止用于遍历索引数组！只能遍历关联数组或对象
因为: in不但遍历当前对象的每个属性（包括数字下标和非数字下标），且会自动沿_ _proto_ _继续遍历父对象中的未隐藏的成员！
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/prototype5.png)

### 14.this指向问题

```
总结: this 4种: 判断this，一定不要看定义在哪儿！只看调用时！
1. obj.fun()   this->obj
2. fun() 或 (function(){ ... })()    this->window
3. new Fun()   this->new正在创建的新对象
4. 类型名.prototype.共有方法=function(){ ... }   this->将来谁调用指谁，同第一种情况
```

### 15.自定义继承

```
1. 问题: 如果整个父对象都不是想要的！
	解决: 其实可以修改一个对象的父对象——换爹
2. 如何: 2种: 
	(1). 只更换一个对象的父对象: 其实就是修改对象的_ _proto_ _继承新的父对象
	a. 子对象._ _proto_ _=新父对象
	b. 问题: 有些浏览器不允许擅自修改_ _proto_ _
		解决: Object.setPrototypeOf(子对象, 新父对象) —— 今后建议
                 设置原型对象的子对象(为)新父对象
    c.仅更换hmm一个对象的爹
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    function Student(sname,sage){
      this.sname=sname;
      this.sage=sage;
    }
    var lilei=new Student("Li Lei",18);
    var hmm=new Student("Han Meimei",19);

    var father={
      bal:100000000000,
      car:"infiniti"
    }

    console.log(lilei);
    console.log(hmm);

    //hmm修改自己的_ _proto_ _属性指向father
    // hmm.__proto__=father;
    Object.setPrototypeOf(hmm, father);
    //比较: 
    console.log(hmm.bal, hmm.car);
    console.log(lilei.bal, lilei.car);

  </script>
</body>
</html>
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/prototype6.png)

```
(2). 更换所有子对象的父对象: 
	a. 其实就是更换构造函数的prototype属性: 
	构造函数.prototype=新父对象
	b. 时机: 必须在创建子对象之前就要更换！
	c. 示例: 同时更换lilei和hmm的父对象
```

![image](https://github.com/baozi9530/web-notes/blob/main/data/obj/prototype7.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    function Student(sname,sage){
      this.sname=sname;
      this.sage=sage;
    }
    
    var father={
      bal:100000000000,
      car:"infiniti"
    }

    //在生lilei和hmm之前就换原型对象: 
    Student.prototype=father;

    var lilei=new Student("Li Lei",18);
    var hmm=new Student("Han Meimei",19);
    console.log(lilei);
    console.log(hmm);
    //结果: 
    console.log(lilei.bal, lilei.car);
    console.log(hmm.bal, hmm.car);
  </script>
</body>
</html>
```

