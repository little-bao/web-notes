## 一.String类型提供的正则相关的函数:3件事

### 1.查找敏感词

```
 用正则查找一句话中包含的敏感词,共四种情况
```

#### 1)indexOf

```
只查找一个固定的敏感词出现的位置

var i = str.indexOf("敏感词");
意为: 在str中查找第一个"敏感词"出现的下标的位置
返回值: 
	①如果找到,返回敏感词第一个字在字符串中的下标位置
	②如果未找到,则返回-1
问题: 不支持正则!只能找一种固定的敏感词
```

```html
<!--按住ctrl+滚轮，缩放字体-->
<!--输入!按回车，可生成网页基本结构-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!--第三阶段必须都用右键 live server运行！-->
  <!--网页中如果写js，都要写在script标签中-->
  <script>
    //请用户输入一条消息内容
    var msg = prompt("请输入消息内容");
    //查找消息中是否包含敏感词我草
    var i = msg.indexOf("我草");
    //如果找到敏感词，返回敏感词位置
    //如果没找到敏感词，返回-1
    //如果包含敏感词
    if(i != -1){
       //就在网页中提示红字: 包含敏感词，禁止发送
      //``和${}不会的同学去第一阶段复习模板字符串
	 //  (向) 页面(中)写  (一条HTML代码片段)
      document.write(`<h1 style="color:red">包含敏感词，禁止发送</h1>`)
    }else{//否则如果不包含敏感词
      //就在网页中提示绿字：然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说: ${msg}</h1>`)
    }
  </script>
</body>
</html>
```

#### 2)search()

```
用正则查找多种敏感词出现的位置
var i = str.search(/正则/i);
意为: 在字符串str中查找第一个符合正则要求的敏感词出现的位置
返回值: 同indexOf完全一样
	①如果找到,返回敏感词第一个字在字符串中的下标位置
	②如果未找到,返回-1
问题: 虽然在猫头鹰里有个选项可以忽略大小写,但是正则表达式天生是区分大小写的!
解决: 在第二个/后添加后缀i即可,ignore忽略大小写
问题:只能查找敏感词的位置,无法获得敏感词的内容
示例: 使用search代替indexOf查找敏感词
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //请用户输入一条消息内容
    var msg=prompt("请输入消息内容");
    //查找消息中是否包含符合正则要求的敏感词
    var i=msg.search(/([我卧]|wo)\s*([艹槽操草]|cao)/i);
    //如果找到敏感词，返回敏感词位置
    //如果没找到敏感词，返回-1
    //如果包含敏感词
    if(i!=-1){
      //就在网页中提示红字: 包含敏感词，禁止发送
      //``和${}不会的同学去第一阶段复习模板字符串
//  (向) 页面(中)写  (一条HTML代码片段)
      document.write(`<h1 style="color:red">包含敏感词，禁止发送</h1>`)
    }else{//否则如果不包含敏感词
      //就在网页中提示绿字：然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说: ${msg}</h1>`)
    }
  </script>
</body>
</html>
```

#### 3)查找敏感词的内容: 2种 match()

##### ①只查找第一个敏感词的内容和位置

```
var arr = str.match(/正则/i);
意为: 在字符串str中查找第一个符合正则要求的敏感词的内容和位置
返回值:2种:
	Ⅰ.如果找到,返回一个数组,arr:[0:"敏感词内容","index":敏感词下标位置]
	如果想获得本次找到的关键词内容:标准:arr["0"] 简写: arr[0]
	如果想获得本次找到的关键词的下标位置:标准:arr["index"] 简写arr.index
	说明: 0和index是不能改名的,因为数组是match函数返回给我们的,不是我们自己创建的
	Ⅱ.如果没找到,返回null
	问题: 如果一句话中包含多个敏感词,match默认只能找第一个敏感词,无法获得所有敏感词
```

```html
练习: 使用match查找敏感词的内容和位置

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //请用户输入一条消息内容
    var msg=prompt("请输入消息内容");
    //查找消息中第一个敏感词的内容和位置
    var arr=msg.match(/([我卧]|wo)\s*([艹槽操草]|cao)/i);
    //如果找到敏感词，返回数组
    //如果没找到敏感词，返回null
    //如果包含敏感词
    if(arr!=null){
      //就在网页中提示红字: 在位置?发现敏感词?，禁止发送
      //``和${}不会的同学去第一阶段复习模板字符串
//  (向) 页面(中)写  (一条HTML代码片段)
      document.write(`<h1 style="color:red">在位置 ${arr.index} 发现敏感词"${arr[0]}"，禁止发送</h1>`)
    }else{//否则如果不包含敏感词
      //就在网页中提示绿字：然哥说: 消息内容
      document.write(`<h1 style="color:green">然哥说: ${msg}</h1>`)
    }
  </script>
</body>
</html>
```

##### ①查找所有敏感词的内容

```
var arr = str.match(/正则/ig);  g:global,查找全部敏感词
返回值: 
	Ⅰ.如果找到敏感词,则返回一个数组,只包含所有敏感词的内容,不再包含每个敏感词的位置
	Ⅱ.如果找不到敏感词,返回null
问题: 不加g时,只能找一个,无法找所有;加g时,能找所有敏感词,但是无法获得位置
```

```html
使用match查找所有敏感词的内容:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var str="老师:请用小红 我的 朋友造句。小亮:小红是我的朋友。小然:朋友！小红是我的！";
    //希望查找出str中所有以小字开头的人名
    //因为汉字没有大小写之分，所以不用加i。
    var arr=str.match(/小[\u4e00-\u9fa5]/g);
    console.log(arr);
  </script>
</body>
</html>
```

#### 3)既查找每个关键词的内容,又查找每个关键字的位置

```
String类型没有提供这种函数
RegExp类型提供了一个reg.exec()函数
```

#### 4)总结

```
查找方法的返回值规律:
1.如果原函数返回的是下标位置,如果找不到,都返回-1
2.如果原函数返回的是一个数组或一个对象,如果找不到,都返回null
注意:如果一个函数有可能返回null!一定先判断是不是null,再使用.并且为null的情况提供备选方案.
```

### 2.替换敏感词 replace

```
将找到的敏感词替换为新内容，2种:
```

##### ①简单查询

```
①简单替换: 将所有敏感词都替换为统一的新值
a. var 变量=str.replace(/正则/ig, "新值")
		          替换
b. 意为: 替换字符串str中所有符合正则要求的敏感词为统一的新值！
c. 强调: 因为所有字符串类型都是不可变类型，所以，replace无权修改原字符串，而是返回替换后的新字符串。原字符串保持不变。所以，必须用变量接住返回值，才能获得替换后的新字符串。
数组是可变类型:数组家函数有权直接修改原数组内容的,所以大部分数组家的函数调用时,无需使用变量接住返回值,就可直接修改原数组!
```



```html
练习: 使用replace替换所有人名为**
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var str="老师:请用小红 我的 朋友造句。小亮:小红是我的朋友。小然:朋友！小红是我的！";
    // var str="you can you up!no can no bibi!";
    //先用match在替换之前找一次
    var arr=str.match(/小[\u4e00-\u9fa5]/g);
    //然后查找结果的元素个数，也就是将来要替换的个数！
    console.log(arr);//null
    //希望替换str中所有以小字开头的人名为**
    str=str.replace(/小[\u4e00-\u9fa5]/g, "**");
    console.log(str);
    //还想显示共替换了多少处！
    //基础一般: 
    //如果match找到了敏感词，才输出arr.length
    if(arr!=null){
      console.log(`共替换了${arr.length}处`);
    }else{//否则如果match没找到敏感词，就直接输出0处代替
      console.log(`共替换了0处`);
    }
    //学有余力: //复习第一阶段三目运算
    //console.log(`共替换了${arr!=null?arr.length:0}处`)
  </script>
</body>
</html>
```

#### ②高级替换

```
②高级替换: 根据每次找到的敏感词不同，动态替换成不同的新值

	a. var 变量=str.replace(/正则/ig, function(形参){
		return 根据本次"形参"获得的敏感词内容，动态生成一个新值
	  })
	  
	b. 原理: 回调函数的学习，可以靠打桩来判断执行次数，传入参数和返回值。
		1). replace会用正则表达式查找str中所有符合正则要求的敏感词
		2). 每找到一个敏感词就自动调用一次回调函数。
		3). 每次调用回调函数时，都自动将本次找到的一个敏感词内容传给形参变量。
		4). 回调函数中根据本次找到的敏感词内容，动态生成一个新值，返回出来
		5). replace函数获得回调函数返回的新值，并自动替换到字符串中本次找到的敏感词位置
```

```html
练习: 将字符串中每个单词首字母改为大写

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //鄙视题: 将字符串中每个单词首字母转为大写
    var str="you can you up";
    // 敏感词:y    c   y   u
    // 		 ↓
    str=str.replace(/\b[a-z]/ig, function(形参){
      //打桩可以让回调函数执行过程现原形！
      console.log(`调用了一次回调函数,形参=${形参},返回${形参.toUpperCase()}`);
      //形参: 4种可能: y c y u
      return 形参.toUpperCase();
      //返回: 也4种可能Y C Y U
    })
    console.log(str);//"You Can You Up";
  </script>
</body>
</html>
运行结果: 
调用了一次回调函数,形参=y,返回Y
调用了一次回调函数,形参=c,返回C
调用了一次回调函数,形参=y,返回Y
调用了一次回调函数,形参=u,返回U
You Can You Up
```

#### ③衍生操作

```
删除敏感词: 其实就是将敏感词替换为空字符串
变量=str.replace(/正则/ig, "")
```

```html
练习:(鄙视题) 定义三个函数，分别去掉字符串开头的空字符，去掉结尾的空字符，以及同时去掉字符串开头和结尾的空字符: 
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //鄙视题三个函数: 
    //修剪
    //trimLeft() 可去掉字符串开头的空字符
    //                可以改名
    // function trimLeft(字符串){
    //   var str2=字符串.replace(/^\s+/,"");
    //   return str2;
    // }
    //trimRight() 可去掉字符串结尾的空字符
    // function trimRight(字符串){
    //   var str2=字符串.replace(/\s+$/,"");
    //   return str2;
    // }
    //trim() 可去掉字符串开头和结尾的空字符
    // function trim(字符串){
    //   //因为/^\s+|\s+$/在字符串中匹配到两组敏感词，一组是开头的空字符，一组是结尾的空字符。如果想把两组空字符都替换，必须加g。
    //   return 字符串.replace(/^\s+|\s+$/g,"")
    // }
    //测试: 
    var str="   hello   world    ";
    // console.log(trimLeft(str));//"hello   world    "
    // console.log(trimRight(str));//"   hello   world"
    // console.log(trim(str));//"hello   world"
    
    //其实ES5和ES6标准中，已经新增了现成的trim系列函数，不用自己定义。
    console.log(str.trimLeft());
    console.log(str.trimRight());
    console.log(str.trim());
  </script>
</body>
</html>
运行结果： 
hello   world    
    hello   world
hello   world
```

### 3.切割字符串 split()

```
按指定的切割符,把一个完整的字符串,切割为多段子字符串
```

#### 1)简单切割:切割符是固定的

```
a. var arr=str.split("切割符")
		       切割
b. 按照字符串str中指定的切割符，将字符串切割为多段子字符串
c. 返回值: 包含切割后的多段子字符串的数组
d. 强调: 切割后的结果中，不包含切割符的！
```

#### 2)复杂切割

```
切割符不是固定的，但是却能找到规律
a. var arr=str.split(/正则/);
b. 意为: 按str中所有符合正则要求的切割符将字符串切割为多段子字符串
c. 强调: split中不用加g，也能自动找到所有符合条件的切割符！
```

```html
练习: 分别使用固定切割符和正则表达式切割字符串
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //想把电子邮件切割为用户名和域名两部分
    var email="zhangdong@tedu.cn";
    //                  |
    //      ["zhangdong","tedu.cn"]
    //            0          1
    //按@将字符串email一分为二
    var arr=email.split("@");
    console.log(arr);
    var uname=arr[0];
    var domain=arr[1];
    console.log(uname, domain);

    //想把一个英文的句子切割为单词数组
    var str="you can you up";
    //按空格切割str
    var arr=str.split(" ");
    console.log(arr);

    //如果每个单词之间的空格个数不确定有几个？
    var str="you       can you   up";
    //按一个或多个空格切割str
    var arr=str.split(/\s+/);
    console.log(arr);
  </script>
</body>
</html>
运行结果：
(2) ["zhangdong", "tedu.cn"]
zhangdong tedu.cn
(4) ["you", "can", "you", "up"]
(4) ["you", "can", "you", "up"]
```

#### 3)翻转字符串

```
a. 问题: 虽然数组和字符串都有下标，但是因为字符串和数组不是同一类型，所以字符串用不了数组家的函数！

b. 解决: 先将字符串打散为一个一个字符组成的字符数组！然后就可以调用数组家的函数。只不过，加工完成后，一定再拼接回字符串！

c. 如何将字符串打散为字符数组: 用空字符串""切割
	var arr=str.split("");
```

```html
练习:翻转字符串
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //数组家现成的reverse函数
    var arr=[1,2,3,4,5];
    arr.reverse();
        //翻转
    console.log(arr);
    
    //鄙视题: 翻转字符串： 
    var str="helloworld";
    //       0123456789.length=10
    //console.log(str[1]);//e
    //console.log(str.length);//10
    //数组家不是有reverse()函数吗?
    //错误: 
    //str.reverse();//报错：str.reverse is not a function
    //正确: 
    var arr=str.split("");//1. 打散为字符数组
    console.log(arr);
    arr.reverse();//2. 翻转字符数组的内容
    console.log(arr);
    //错误: join()什么都不写，默认用,连接每个字符
    //str=arr.join();
    //正确: 
    str=arr.join("");//3. 将翻转后的字符数组无缝拼接回字符串
    console.log(str);//"dlrowolleh"
  </script>
</body>
</html>
运行结果: 
(5) [5, 4, 3, 2, 1]
(10) ["h", "e", "l", "l", "o", "w", "o", "r", "l", "d"]
(10) ["d", "l", "r", "o", "w", "o", "l", "l", "e", "h"]
dlrowolleh
```

## 二.补充知识

```
补第一阶段: 字符串其实是一种不可变类型！
1. 不可变类型: 一旦创建值不可改变，只能整体替换！
   直接后果: 所有字符串家的函数都无权直接修改原字符串。只能创建新字符串保存加工后的结果，并返回新字符串。原字符串始终保持不变！
   强调: 所有字符串家的函数执行后的结果，必须用变量接住，才能保存下来！
2. 可变类型: 创建后，还可改变其内容。比如: 数组
   比如: 数组排序arr.sort(), 向数组中追加一个新元素arr.push(xxx), 都直接修改原数组，无需用变量=接住
```

```
补第一阶段数组本质: 
1. 索引数组: 下标都是数字的数组，比如: var arr=[1,2,3]; 
   结果: [
     0: 1,
     1: 2,
     2: 3
   ]
2. 关联数组: 下标都是自定义名称，比如: 
   var ym=[];
   ym["数学"]=89,
   ym["语文"]=61,
   ym["英语"]=91
   结果: [
     "数学": 89,
     "语文": 61,
     "英语": 91
   ]
3. 其实: js中所有数组以及对象底层都是关联数组！本质上是没有索引数组！
   (1). 数组和对象底层，其实都是名值对儿的集合
   (2). 每个数组的下标和每个对象属性的属性名，都是字符串类型
   (3). 无论访问数组的元素，还是访问对象的属性，标准写法都是["下标名称"]
   (4). 简写: 
   a. 如果下标名称不是数字，可简写为".下标名称"
   b. 如果下标是数字，只能简写为"[下标]"，不能用.
       因为".数字"和程序中的小数点冲突了！
```





